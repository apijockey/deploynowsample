{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"APIJockey TEST Online Help APIJockey TEST will help you assess and verify web services responses and automate this assessment. Important features Import and view WSDL definitions Run data-based Testcases A full featured WSDL schema validation MTOM-Support for SOAP request and SOAP response Syntax Highlighting for XML, JSONPath and JSON Randomized value lists and data type specific ranges Data transfer with XPath, XQuery and JSONPath Assertions with XPath and JSONPath Business test friendly assertion support to reduce detailed knowledge about query-languages like XPath and JSONPath Variables support for requests, urls, XPath, JSONPath and XQuery expressions Run Environment support to centralize authentication and URL-information Instant Test runs Persist test executions with comprehensive storage of test step details Backup and share repository snapshots (requires Sign-in and a paying subscription). What's new APIJockey TEST received a substantial update for tabular data in both the views and the editors. User Guides Concepts Data based test Run environments Reference Test hierarchy views Testep views Configuration views and editors Copy and Paste Collaborate Release notes Tutorials Getting started Create your first tests Create databased testcase Random test data support","title":"Home"},{"location":"#apijockey-test-online-help","text":"APIJockey TEST will help you assess and verify web services responses and automate this assessment.","title":"APIJockey TEST Online Help"},{"location":"#important-features","text":"Import and view WSDL definitions Run data-based Testcases A full featured WSDL schema validation MTOM-Support for SOAP request and SOAP response Syntax Highlighting for XML, JSONPath and JSON Randomized value lists and data type specific ranges Data transfer with XPath, XQuery and JSONPath Assertions with XPath and JSONPath Business test friendly assertion support to reduce detailed knowledge about query-languages like XPath and JSONPath Variables support for requests, urls, XPath, JSONPath and XQuery expressions Run Environment support to centralize authentication and URL-information Instant Test runs Persist test executions with comprehensive storage of test step details Backup and share repository snapshots (requires Sign-in and a paying subscription).","title":"Important features"},{"location":"#whats-new","text":"APIJockey TEST received a substantial update for tabular data in both the views and the editors.","title":"What's new"},{"location":"#user-guides","text":"Concepts Data based test Run environments","title":"User Guides"},{"location":"#reference","text":"Test hierarchy views Testep views Configuration views and editors Copy and Paste Collaborate Release notes","title":"Reference"},{"location":"#tutorials","text":"Getting started Create your first tests Create databased testcase Random test data support","title":"Tutorials"},{"location":"collaborate/","text":"Import and export your test definitions APIJockey Test helps you define and run your tests. There will be situations where you want to share your tests with others or want to run tests in APIJockey Test that you created in other solutions This is where import and export of tests comes in handy. The export and import uses a JSON-structure, which is described below in more detail. Import and export options You can import and export A selection of Testcases A selection of Testsets A selection of Repositories Export a selection of testcases If you want to export a Testcase selection (one or several Testcases), you need to select these Testcases and press export selected Testcases . When you click the button, a save as Dialog appears with a preset filename in the downloads folder. After you have confirmed with save you will find the JSON-File in the selected folder. Export a selection of testsets The Testset list view can be hidden or displayed by enabling/disabling the toggle element, IF the Repository list view is enabled. If you see the dropdown list for your repository selection, this toggle is not visible. If you want to export a Testset selection (one or several Testsets), you need to select these Testsets and press export selected Testsets . When you click the button, a save as Dialog appears with a preset filename in the downloads folder. After you have confirmed with Save you will find the JSON-File in the selected folder. Export a selection of Repositories If you want to export a Repository selection (on or several Repositories, select these Repositories. When you click the button, a save as Dialog appears with a preset filename in the downloads folder. This follows the same rules as for testcases and testsets, but uses the termin Repository as the start of the filename. Import testcases When you want to import Testcases, you must press the import elements button in the Testcase List View This button makes no distinction of your current selection and would simple add Testcases to the current Testcase list. When you press the button, an Open Dialog comes up, where you can select any file. A Testcase Decoder will try to read a JSON-structure representing a list of 1 - n Testcases. If this is successful, the Testcase will appear in the list with Testcase names prefixed with the filename that you chose. Assume we had exported the existing Testcase and would import it back, we would get the following list: Import testsets When you want to import Testsets, you must press the import elements button in the Testset List View ![screenshot with button import testsets] (storage/ImportTestsets.png) This import action makes no distinction of your current selection and would simply add Testcases to the current Testcase list. When you press the button, an Open Dialog comes up, where you can select any file. A Testcase Decoder will try to read a JSON-structure representing a list of 1 - n Testcases. If this is successful, the Testsets will appear in the list with Testcase names prefixed by the filename that you chose. Assume we had exported the existing Testcase and would import it back, we would get the following list: Import repositories The Repository list view can be displayed as dropdown list or as an editable list view, When you want to import Testsets, you must press the import elements button in the Testset List View This import action makes no distinction of your current selection and would simply add Repositories to the current Repository list. When you press the button, an Open Dialog comes up, where you can select any file. A Repository Decoder will try to read a JSON-structure representing a list of 1 - n Repositories. If this is successful, the repositories will appear in the list with Repository names prefixed by the filename that you chose. Assume we had exported the existing repository and would import it back, we would get the following list: Scope of an export and import The export and import facility will include everything that you can define in the Testdefinition hierarchy Variables Assertions ValueProvider ValueTransfers (Link between Variables and ValueProviders Not included are these elements Service definitions Run Environments Run Executions This means, if you export an HTTP Teststeps and SOAPTeststeps that have a ServiceDefinitionReference, the one that would import it, MUST first create these ServiceDefinitions. If not the import reacts as follows: An HTTP Teststep will be imported, but without ServiceDefinitionReference A SOAP Teststep that does not find a ServiceDefinition will lead to an import failure. See Options to import SOAP Teststeps to understand alternatives and prerequisites. Options to import SOAP Requests/tests SOAP Requests can be included in HTTP Teststeps and SOAP Teststeps. The basic difference is three degree of support in the test definition HTTP Teststeps do not support schema validation HTTP Teststeps have no reference to a WSDL SOAP Teststeps require this reference and can therefore perform a schema validation SOAP Teststeps allow you to define XPath-based validations, which is not available for HTTP Teststeps When you import a SOAP Request/Test you will need to decide which Teststep you want to create in APIJockey Test, as the Teststep Decoder identifies the type of Teststeps and creates a new instance of this exact type. With these, you may create a custom import or export script to any other third party application. For some of these we provide you sample scripts, for your convenience and without any warrenty or liability. Possible error situations When you import a JSON that does not conform to the exected input, like: You try to import testcases in the testset or repository list or vice versa You try to import any JSON structure that does not represent the expected structure the import will fail, and eventually report the missing JSON key. When you try to import a SOAP Teststeps, the decoder will try to find the referenced WSDL / Binding / SOAP operation in these keys: serviceDefinition , this key must contain a URL that returns the WSDL. This WSDL must be present as WSDL Service Definition Content wsdlServiceBindingQName , this key value must contain a QName with the target namespace of the service definition and the Binding name. soapoperationQName , this key value must must contain a QName with the target namespace of the service definition and the soap operation name. Sample scripts to export from third party applications You can download a sample groovy script to export SOAP Teststeps to the supported imported/exported JSON-format. This script is provided under the MIT License (see opensource.org) , please make sure you understand and accept this license, before you use the script. Steps to use this script You create a groovy script as a teststep in SoapUI or ReadyAPI, and copy the provided groovy script Modification details are provided within the script. Please understand, this script is made with best intentions to support collaboration, but changes may occur in these third party applications that we are not aware of, you use this script at your own risk. soapuiexport groovy script","title":"Collaborate"},{"location":"collaborate/#import-and-export-your-test-definitions","text":"APIJockey Test helps you define and run your tests. There will be situations where you want to share your tests with others or want to run tests in APIJockey Test that you created in other solutions This is where import and export of tests comes in handy. The export and import uses a JSON-structure, which is described below in more detail.","title":"Import and export your test definitions"},{"location":"collaborate/#import-and-export-options","text":"You can import and export A selection of Testcases A selection of Testsets A selection of Repositories","title":"Import and export options"},{"location":"collaborate/#export-a-selection-of-testcases","text":"If you want to export a Testcase selection (one or several Testcases), you need to select these Testcases and press export selected Testcases . When you click the button, a save as Dialog appears with a preset filename in the downloads folder. After you have confirmed with save you will find the JSON-File in the selected folder.","title":"Export a selection of testcases"},{"location":"collaborate/#export-a-selection-of-testsets","text":"The Testset list view can be hidden or displayed by enabling/disabling the toggle element, IF the Repository list view is enabled. If you see the dropdown list for your repository selection, this toggle is not visible. If you want to export a Testset selection (one or several Testsets), you need to select these Testsets and press export selected Testsets . When you click the button, a save as Dialog appears with a preset filename in the downloads folder. After you have confirmed with Save you will find the JSON-File in the selected folder.","title":"Export a selection of testsets"},{"location":"collaborate/#export-a-selection-of-repositories","text":"If you want to export a Repository selection (on or several Repositories, select these Repositories. When you click the button, a save as Dialog appears with a preset filename in the downloads folder. This follows the same rules as for testcases and testsets, but uses the termin Repository as the start of the filename.","title":"Export a selection of Repositories"},{"location":"collaborate/#import-testcases","text":"When you want to import Testcases, you must press the import elements button in the Testcase List View This button makes no distinction of your current selection and would simple add Testcases to the current Testcase list. When you press the button, an Open Dialog comes up, where you can select any file. A Testcase Decoder will try to read a JSON-structure representing a list of 1 - n Testcases. If this is successful, the Testcase will appear in the list with Testcase names prefixed with the filename that you chose. Assume we had exported the existing Testcase and would import it back, we would get the following list:","title":"Import testcases"},{"location":"collaborate/#import-testsets","text":"When you want to import Testsets, you must press the import elements button in the Testset List View ![screenshot with button import testsets] (storage/ImportTestsets.png) This import action makes no distinction of your current selection and would simply add Testcases to the current Testcase list. When you press the button, an Open Dialog comes up, where you can select any file. A Testcase Decoder will try to read a JSON-structure representing a list of 1 - n Testcases. If this is successful, the Testsets will appear in the list with Testcase names prefixed by the filename that you chose. Assume we had exported the existing Testcase and would import it back, we would get the following list:","title":"Import testsets"},{"location":"collaborate/#import-repositories","text":"The Repository list view can be displayed as dropdown list or as an editable list view, When you want to import Testsets, you must press the import elements button in the Testset List View This import action makes no distinction of your current selection and would simply add Repositories to the current Repository list. When you press the button, an Open Dialog comes up, where you can select any file. A Repository Decoder will try to read a JSON-structure representing a list of 1 - n Repositories. If this is successful, the repositories will appear in the list with Repository names prefixed by the filename that you chose. Assume we had exported the existing repository and would import it back, we would get the following list:","title":"Import repositories"},{"location":"collaborate/#scope-of-an-export-and-import","text":"The export and import facility will include everything that you can define in the Testdefinition hierarchy Variables Assertions ValueProvider ValueTransfers (Link between Variables and ValueProviders Not included are these elements Service definitions Run Environments Run Executions This means, if you export an HTTP Teststeps and SOAPTeststeps that have a ServiceDefinitionReference, the one that would import it, MUST first create these ServiceDefinitions. If not the import reacts as follows: An HTTP Teststep will be imported, but without ServiceDefinitionReference A SOAP Teststep that does not find a ServiceDefinition will lead to an import failure. See Options to import SOAP Teststeps to understand alternatives and prerequisites.","title":"Scope of an export and import"},{"location":"collaborate/#options-to-import-soap-requeststests","text":"SOAP Requests can be included in HTTP Teststeps and SOAP Teststeps. The basic difference is three degree of support in the test definition HTTP Teststeps do not support schema validation HTTP Teststeps have no reference to a WSDL SOAP Teststeps require this reference and can therefore perform a schema validation SOAP Teststeps allow you to define XPath-based validations, which is not available for HTTP Teststeps When you import a SOAP Request/Test you will need to decide which Teststep you want to create in APIJockey Test, as the Teststep Decoder identifies the type of Teststeps and creates a new instance of this exact type. With these, you may create a custom import or export script to any other third party application. For some of these we provide you sample scripts, for your convenience and without any warrenty or liability.","title":"Options to import SOAP Requests/tests"},{"location":"collaborate/#possible-error-situations","text":"When you import a JSON that does not conform to the exected input, like: You try to import testcases in the testset or repository list or vice versa You try to import any JSON structure that does not represent the expected structure the import will fail, and eventually report the missing JSON key. When you try to import a SOAP Teststeps, the decoder will try to find the referenced WSDL / Binding / SOAP operation in these keys: serviceDefinition , this key must contain a URL that returns the WSDL. This WSDL must be present as WSDL Service Definition Content wsdlServiceBindingQName , this key value must contain a QName with the target namespace of the service definition and the Binding name. soapoperationQName , this key value must must contain a QName with the target namespace of the service definition and the soap operation name.","title":"Possible error situations"},{"location":"collaborate/#sample-scripts-to-export-from-third-party-applications","text":"You can download a sample groovy script to export SOAP Teststeps to the supported imported/exported JSON-format. This script is provided under the MIT License (see opensource.org) , please make sure you understand and accept this license, before you use the script. Steps to use this script You create a groovy script as a teststep in SoapUI or ReadyAPI, and copy the provided groovy script Modification details are provided within the script. Please understand, this script is made with best intentions to support collaboration, but changes may occur in these third party applications that we are not aware of, you use this script at your own risk. soapuiexport groovy script","title":"Sample scripts to export from third party applications"},{"location":"concepts/","text":"APIJockey TEST concepts APIJockey TEST is a test application. It's primary purpose is to test webservices. Webservices have been around for a long time now, starting with SOAP whereas current implementations focus on JSON-based implmentations with or withour a REST architecture. Testing web services is not an easy task, there is no user interface, there is no backing process, data models use keys and reference ids. Creating valid requests is time-consuming and verifying responses is evenharder. APIJockey TEST will help you create requests, assess and verify web services responses and automate this assessment to a certain degree. All information is stored in a SQLite database and backed by iCloud integration, which ensures you can access your data from different MacOS \u00ae computers. instant test runs Persisted Test executions Instant test runs This test is available on all four test definition hierarchies. Repository Testset Testcase Teststep All test runnable elements provide a play button that starts the test run. A result status icon provides visible information of the test result status. Above: screenshot of the teststep action buttons with test run result icon Test executions Test executions are persisted test runs. They can be started from the repository or testset list view and perform basically the same test operations as an instant test run. The difference is that the test execution results are persisted and can be accessed at any point in time. This gives you a great opportunity to get back to previous runs and compare requests and responses. Above: screenshot of the test execution view When you select a test execution, you will see the list of testcase executions and teststeps execution, drilled down to each indivudal Random and Teststep Value Provider output value. Test definition APIJockey TEST to organize tests in a test definition hierarchy . A test definition describes a test case with its test steps and the assertions defined on the teststeps. That means, a test case can be passed in a test run only, when all teststeps can be run through and all assertions have passed. Repository First step in the test definition is the creation of a repository. You can create as many repositories as you want. A Repository contains a structure of test cases AND you can execute the contained testcases.Repositories are intended to support several container types, although APIJockey TEST currently supports one local SQLLite (technically CoreData) database, only. They help you group your tests and support persisted test executions. See, how to create a test definition Organize your repostories in the Repository list view Testset Once you have created a repository, you start to create Testsets. Testsets contain the actual Testcases. Testsets can be applied for various differenciations like use cases, types of tests (regression tests, new development). Testing includes several tasks, such as: regressions testing test new functionality exploration testing persisted test run executions Testsets will help you to organize large sets of Testcases. Find help to manage your testsets in Testset list view Testsets should not be used to differenciate test environments. Testsets make also sense, when Testcases use common variable data. Find help to manage your testsets in the Testset list view Testcase A testcase - represents what you want to test. defines the teststeps, the assertions and validations to test a functionality. can include several endpoints can run with randomized data and capture data from its test steps has run successfully, if all Teststeps have run successfully. There are two types of testcases: A testcase that runs each teststep once. A data based testcase that runs teststeps based on a set of input data for each entry in this data set. Find help to manage your testcases in Testcase list view ) You define the actual Testcase on a Testset. You can create an arbitrary number of Testcases on a Testset. Teststep APIJockey TEST supports a numbe of teststeps that you can create and arrange however you like and need to A Teststep is a concrete step in you Testcase run. - You run a SOAPTeststep or HTTPTeststep to send a request and receive a response. - You may assert this response. - You may tranfer response information to a variable which in turn is a prerequisite of subsequent teststeps. Each of these teststeps has configuration options, see how to create: HTTP Teststep SOAP Teststep Manual RandomizedValuelistTeststep RandomizeTeststep RandomizedValuelistTeststep Organize your tests in the Teststep list view Manage your View RandomizedValuelistTeststep Manage your View Manual RandomizedValuelistTeststep Manage your View DatatransferTeststep These teststeps can be combined. You can even define data input teststeps that allow you to iterate over a set of data. The following sample demonstrate a set of web service eststeps, together with a Datatransferteststep and a Randomizeteststep. The Data Loop Input Teststep defines a set of data to iterate over. getData requests data from a web service transfer retrieves response data and stores them in variables. randomize dates provides random dates (effective dates) getChange requests a quote for change to an existing contract setChangeTransfer provides data from getChange to setChange setChange requests the actual change on the existing contract StatusSetChange store response data for the final step Data Loop Result Teststep stores the current loop results in an internal table that may be exported on user request. All this without ANY coding. Variables A Variable holds a persisted value. It is intended to reuse data acroll test hierarchies and elements. Conceptual Overview A Variable can be defined for the four following test definition hierarchy elements. A Variable name must be unique for an element it is assigned to. Variable Holder types Variables can be assigned to these four test definition elements, sometimes referred to as holder types - Repository Testset Testcase Teststep Variable types The variable type depends on the selected tab in the editor: - String Arbitrary Text Password Any text. This types hides the value in the variable list view and during edits and be undisclosed on demand absolute Date Enter a static date to reproduce tests. The Variable Editor provides a convenient means to enter the date and formatting for the service call. relative Date Creates a date relative to the current date. On Test runs, this relative is re-evaluated .This allows you to enter a date of birth or a date of manufacturing and make sure the webservice under test will always calculate the same age. Number Numbers need specific formatting. This formatting is provided for variables of type number Boolean Booleans have 0 / 1 values. The variable editor allows use of true/false or yes/no as text for the boolean values. Create a Variable Variables can be created on two different places: In the variables view, this is explained in Variables View In the variables assignment view on Teststep ValueProviders and Random ValueProvider Access Variable values Variable placeholders are simply substituted by their current values, just like a makro. Variable values can be used in these contexts: SOAP/HTTP Requests URLs of the SOAP Request XPath expression for Assertions and ValueProviders XQuery expressions for ValueProviders Variable access syntax Teststep variables: $(Teststep.<variablename>) Teststep variables: $(Testcase.<variablename>) Testset variables: $(Testset.<variablename>) Repository variables: $(Repository.<variablename>) VariableValueTransfer When you want to update your variable from within a test step, you will use a VariableValueTransfer , they are the common component for ValueProviders to transfer data to a variable of type String. Attachment placeholders Attachment placeholders in SOAP Requests are not variables and use a special, but similar naming convention. see SOAP Attachments VariableValueTransfers are used among these teststeps to configure the output variable: DatatransferTeststep RandomizeTeststep RandomizedValuelistTeststep Manual RandomizedValuelistTeststep Static and variable test data User data, response data, derived data and random data are available for your test The most common type of data is user data, ie data that the user enters. A user will enter request data in the request editor.i This approach is valid until request data are repeated for several tests and a change in the webservice definition, such as key lists or expected value, would mean a lot of rework. This is, where variables come into the game. Response Data and Derived data A Webservice is - in general - expected to return values, there may be negative test cases, though. You can access both - request and response data - from a teststep to feed a variable, as shown above, serves as input. APIJockey.com gives two options to to access request and response data: XPath XQuery JSONPath In the request, derived data is just a variable as above. XQuery allows for arbitrary transformations of request and response data, so if you need to test several Web services that expect different contents, XQuery is your choice. XPath, XQuery and JSONPath can be used within DatatransferValueProviders , which in turn are part of Datatransferteststeps. Random Data APIJockey TEST provides a Randomteststep that allows for randomized data. You can create a list of random value providers without any coding. Typical examples are number plates or Vehicle Identification numbers where you may use a calculated String to create the random value. In the request, this is just a variable as above.","title":"Concepts"},{"location":"concepts/#apijockey-test-concepts","text":"APIJockey TEST is a test application. It's primary purpose is to test webservices. Webservices have been around for a long time now, starting with SOAP whereas current implementations focus on JSON-based implmentations with or withour a REST architecture. Testing web services is not an easy task, there is no user interface, there is no backing process, data models use keys and reference ids. Creating valid requests is time-consuming and verifying responses is evenharder. APIJockey TEST will help you create requests, assess and verify web services responses and automate this assessment to a certain degree. All information is stored in a SQLite database and backed by iCloud integration, which ensures you can access your data from different MacOS \u00ae computers. instant test runs Persisted Test executions","title":"APIJockey TEST concepts"},{"location":"concepts/#instant-test-runs","text":"This test is available on all four test definition hierarchies. Repository Testset Testcase Teststep All test runnable elements provide a play button that starts the test run. A result status icon provides visible information of the test result status. Above: screenshot of the teststep action buttons with test run result icon","title":"Instant test runs"},{"location":"concepts/#test-executions","text":"Test executions are persisted test runs. They can be started from the repository or testset list view and perform basically the same test operations as an instant test run. The difference is that the test execution results are persisted and can be accessed at any point in time. This gives you a great opportunity to get back to previous runs and compare requests and responses. Above: screenshot of the test execution view When you select a test execution, you will see the list of testcase executions and teststeps execution, drilled down to each indivudal Random and Teststep Value Provider output value.","title":"Test executions"},{"location":"concepts/#test-definition","text":"APIJockey TEST to organize tests in a test definition hierarchy . A test definition describes a test case with its test steps and the assertions defined on the teststeps. That means, a test case can be passed in a test run only, when all teststeps can be run through and all assertions have passed.","title":"Test definition"},{"location":"concepts/#repository","text":"First step in the test definition is the creation of a repository. You can create as many repositories as you want. A Repository contains a structure of test cases AND you can execute the contained testcases.Repositories are intended to support several container types, although APIJockey TEST currently supports one local SQLLite (technically CoreData) database, only. They help you group your tests and support persisted test executions. See, how to create a test definition Organize your repostories in the Repository list view","title":"Repository"},{"location":"concepts/#testset","text":"Once you have created a repository, you start to create Testsets. Testsets contain the actual Testcases. Testsets can be applied for various differenciations like use cases, types of tests (regression tests, new development). Testing includes several tasks, such as: regressions testing test new functionality exploration testing persisted test run executions Testsets will help you to organize large sets of Testcases. Find help to manage your testsets in Testset list view Testsets should not be used to differenciate test environments. Testsets make also sense, when Testcases use common variable data. Find help to manage your testsets in the Testset list view","title":"Testset"},{"location":"concepts/#testcase","text":"A testcase - represents what you want to test. defines the teststeps, the assertions and validations to test a functionality. can include several endpoints can run with randomized data and capture data from its test steps has run successfully, if all Teststeps have run successfully. There are two types of testcases: A testcase that runs each teststep once. A data based testcase that runs teststeps based on a set of input data for each entry in this data set. Find help to manage your testcases in Testcase list view ) You define the actual Testcase on a Testset. You can create an arbitrary number of Testcases on a Testset.","title":"Testcase"},{"location":"concepts/#teststep","text":"APIJockey TEST supports a numbe of teststeps that you can create and arrange however you like and need to A Teststep is a concrete step in you Testcase run. - You run a SOAPTeststep or HTTPTeststep to send a request and receive a response. - You may assert this response. - You may tranfer response information to a variable which in turn is a prerequisite of subsequent teststeps. Each of these teststeps has configuration options, see how to create: HTTP Teststep SOAP Teststep Manual RandomizedValuelistTeststep RandomizeTeststep RandomizedValuelistTeststep Organize your tests in the Teststep list view Manage your View RandomizedValuelistTeststep Manage your View Manual RandomizedValuelistTeststep Manage your View DatatransferTeststep These teststeps can be combined. You can even define data input teststeps that allow you to iterate over a set of data. The following sample demonstrate a set of web service eststeps, together with a Datatransferteststep and a Randomizeteststep. The Data Loop Input Teststep defines a set of data to iterate over. getData requests data from a web service transfer retrieves response data and stores them in variables. randomize dates provides random dates (effective dates) getChange requests a quote for change to an existing contract setChangeTransfer provides data from getChange to setChange setChange requests the actual change on the existing contract StatusSetChange store response data for the final step Data Loop Result Teststep stores the current loop results in an internal table that may be exported on user request. All this without ANY coding.","title":"Teststep"},{"location":"concepts/#variables","text":"A Variable holds a persisted value. It is intended to reuse data acroll test hierarchies and elements.","title":"Variables"},{"location":"concepts/#conceptual-overview","text":"A Variable can be defined for the four following test definition hierarchy elements. A Variable name must be unique for an element it is assigned to.","title":"Conceptual Overview"},{"location":"concepts/#variable-holder-types","text":"Variables can be assigned to these four test definition elements, sometimes referred to as holder types - Repository Testset Testcase Teststep","title":"Variable Holder types"},{"location":"concepts/#variable-types","text":"The variable type depends on the selected tab in the editor: - String Arbitrary Text Password Any text. This types hides the value in the variable list view and during edits and be undisclosed on demand absolute Date Enter a static date to reproduce tests. The Variable Editor provides a convenient means to enter the date and formatting for the service call. relative Date Creates a date relative to the current date. On Test runs, this relative is re-evaluated .This allows you to enter a date of birth or a date of manufacturing and make sure the webservice under test will always calculate the same age. Number Numbers need specific formatting. This formatting is provided for variables of type number Boolean Booleans have 0 / 1 values. The variable editor allows use of true/false or yes/no as text for the boolean values.","title":"Variable types"},{"location":"concepts/#create-a-variable","text":"Variables can be created on two different places: In the variables view, this is explained in Variables View In the variables assignment view on Teststep ValueProviders and Random ValueProvider","title":"Create a Variable"},{"location":"concepts/#access-variable-values","text":"Variable placeholders are simply substituted by their current values, just like a makro. Variable values can be used in these contexts: SOAP/HTTP Requests URLs of the SOAP Request XPath expression for Assertions and ValueProviders XQuery expressions for ValueProviders","title":"Access Variable values"},{"location":"concepts/#variable-access-syntax","text":"Teststep variables: $(Teststep.<variablename>) Teststep variables: $(Testcase.<variablename>) Testset variables: $(Testset.<variablename>) Repository variables: $(Repository.<variablename>)","title":"Variable access syntax"},{"location":"concepts/#variablevaluetransfer","text":"When you want to update your variable from within a test step, you will use a VariableValueTransfer , they are the common component for ValueProviders to transfer data to a variable of type String.","title":"VariableValueTransfer"},{"location":"concepts/#attachment-placeholders","text":"Attachment placeholders in SOAP Requests are not variables and use a special, but similar naming convention. see SOAP Attachments VariableValueTransfers are used among these teststeps to configure the output variable: DatatransferTeststep RandomizeTeststep RandomizedValuelistTeststep Manual RandomizedValuelistTeststep","title":"Attachment placeholders"},{"location":"concepts/#static-and-variable-test-data","text":"User data, response data, derived data and random data are available for your test The most common type of data is user data, ie data that the user enters. A user will enter request data in the request editor.i This approach is valid until request data are repeated for several tests and a change in the webservice definition, such as key lists or expected value, would mean a lot of rework. This is, where variables come into the game.","title":"Static and variable test data"},{"location":"concepts/#response-data-and-derived-data","text":"A Webservice is - in general - expected to return values, there may be negative test cases, though. You can access both - request and response data - from a teststep to feed a variable, as shown above, serves as input. APIJockey.com gives two options to to access request and response data: XPath XQuery JSONPath In the request, derived data is just a variable as above. XQuery allows for arbitrary transformations of request and response data, so if you need to test several Web services that expect different contents, XQuery is your choice. XPath, XQuery and JSONPath can be used within DatatransferValueProviders , which in turn are part of Datatransferteststeps.","title":"Response Data and Derived data"},{"location":"concepts/#random-data","text":"APIJockey TEST provides a Randomteststep that allows for randomized data. You can create a list of random value providers without any coding. Typical examples are number plates or Vehicle Identification numbers where you may use a calculated String to create the random value. In the request, this is just a variable as above.","title":"Random Data"},{"location":"conceptual-databasedTestcase/","text":"Databased Testcase A databased testcase runs its teststeps repeatedly with varying predefined data in a table. The idea is to assess your service under test with different data and verify the results later in a table. This kind of data-based tests can be achieved with the Testcase type Databased Testcase . See the step-by-step tutorial Create a Databased Testcase for more information how to perform this task. A Databased Testcase is a specific Testcase type that you create in the View Testcase List . It uses the following elements: -A Data Loop Input Teststep that contains the data to iterate over A list of Teststeps that perform the actual service tests with data from the Data Loop Input Teststep A Data Loop Result Teststep that write variable values into a result table Data Loop Input Teststep This teststep is meant to provide the date for the Data Loop. Depending on our edition (Community Edition or Standard Edition) you have two options to provide your tabular data: A Manual Table Editor A configurable CSV file input A Query input, see Create a Query-based Valuelist Input All of these options foresee a mapping between columns of your table and a variable in your Test hierarchy, as you can see in the following screenshot: We define a number of columns for our table We link these columns to variables in our test hierarchy We enter the data (in a manual table) or import the data (and import the column information) from a CSV file When we run this Teststep, the current row data will be read and the information in the row cells will be used to update the referenced variable value Any subsequent Teststep will be able to access the current variable value with the $(Holder.Name) notation Create a Query-based valuelist Input A query-based valuelist input allows you to use a query language like XQuery, XPath or JSONPath to provide variables values from an HTTP/SOAP Teststep response and loop over each element in your Databased Testcase. A query-based valuelist input provides a powerful option to read a list of elements from an HTTP/SOAP Teststep reponse and delivers the top level child elments as columns in table. This is the input for our Databased Testcase Run Loop. The following image shows a sample JSON- response with a number of invoice elements that hold sub elements. We want to iterate over these invoice elements and use the sub elements as columns in an input table, as you would do use a CSV file or a manual table. Use case of a query-based valuelist input We will illustrate this with the following use case, as some transformations would apply when querying JSON-Elements or XML-Elements and provide them as flat table with columns and rows. Let's test a REST-service that exposes two routes: A route/ressource hosturl/api/json/invoices that returns a list of available invoices with some metadata such as invoice number and company A route/ressource hosturl/api/json/invoiceNumber/invoicenumber that returns the invoie document with detailed invoice data such as amount and term We want to verify that each invoice returned from the first route can be received in the second route and want to make sure that the information on the invoice-element corresponds to the metadata returned in the JSON-element. Each element is a JSON-Dictionary that holds three key/value-pairs, the webservice call would return 10 invoice elements: companyname invoicenumber projecttitle We will apply the following JSONPath to extract the information for each Dictionary in the list and create an Input table for our Databased-Testcase: JSONPath: $.invoiceElements.* Here we go. We have the input for the Databased Testcase Run Loop. Each column entry is automatically assigned to a Variable that has been created for you. You may use this in call of the second webservice in such a way: Databased Testcase Run Details A Databased Testcase run performs the following logic: All Teststeps before the the Data Loop Input Teststep will run once All Teststeps between the Data Loop Input Teststep and the Data Loop Result Teststep will run for each row in the Data Loop Input Teststep Each Teststep defines which of the variables it uses, you may use them in the URL as parameter values or in a JSON or SOAP body The Data Loop Result Teststep is the last Teststep that is run repeatedlly All Teststeps after the Data Loop Result Teststep will run once Data Loop Result Teststep This Teststep gives you the option to write any Variable values in the Test definition hierarchy to a result table. This result table is stored internally and can be exported to a CSV-file. You can append new results to the end of the table with new test runs or simply override any existing entry with the option Append to end of file . See the step-by-step tutorial Create a Databased Testcase for more information how to perform this task.","title":"Data based test"},{"location":"conceptual-databasedTestcase/#databased-testcase","text":"A databased testcase runs its teststeps repeatedly with varying predefined data in a table. The idea is to assess your service under test with different data and verify the results later in a table. This kind of data-based tests can be achieved with the Testcase type Databased Testcase . See the step-by-step tutorial Create a Databased Testcase for more information how to perform this task. A Databased Testcase is a specific Testcase type that you create in the View Testcase List . It uses the following elements: -A Data Loop Input Teststep that contains the data to iterate over A list of Teststeps that perform the actual service tests with data from the Data Loop Input Teststep A Data Loop Result Teststep that write variable values into a result table","title":"Databased Testcase"},{"location":"conceptual-databasedTestcase/#data-loop-input-teststep","text":"This teststep is meant to provide the date for the Data Loop. Depending on our edition (Community Edition or Standard Edition) you have two options to provide your tabular data: A Manual Table Editor A configurable CSV file input A Query input, see Create a Query-based Valuelist Input All of these options foresee a mapping between columns of your table and a variable in your Test hierarchy, as you can see in the following screenshot: We define a number of columns for our table We link these columns to variables in our test hierarchy We enter the data (in a manual table) or import the data (and import the column information) from a CSV file When we run this Teststep, the current row data will be read and the information in the row cells will be used to update the referenced variable value Any subsequent Teststep will be able to access the current variable value with the $(Holder.Name) notation","title":"Data Loop Input Teststep"},{"location":"conceptual-databasedTestcase/#create-a-query-based-valuelist-input","text":"A query-based valuelist input allows you to use a query language like XQuery, XPath or JSONPath to provide variables values from an HTTP/SOAP Teststep response and loop over each element in your Databased Testcase. A query-based valuelist input provides a powerful option to read a list of elements from an HTTP/SOAP Teststep reponse and delivers the top level child elments as columns in table. This is the input for our Databased Testcase Run Loop. The following image shows a sample JSON- response with a number of invoice elements that hold sub elements. We want to iterate over these invoice elements and use the sub elements as columns in an input table, as you would do use a CSV file or a manual table.","title":"Create a Query-based valuelist Input"},{"location":"conceptual-databasedTestcase/#use-case-of-a-query-based-valuelist-input","text":"We will illustrate this with the following use case, as some transformations would apply when querying JSON-Elements or XML-Elements and provide them as flat table with columns and rows. Let's test a REST-service that exposes two routes: A route/ressource hosturl/api/json/invoices that returns a list of available invoices with some metadata such as invoice number and company A route/ressource hosturl/api/json/invoiceNumber/invoicenumber that returns the invoie document with detailed invoice data such as amount and term We want to verify that each invoice returned from the first route can be received in the second route and want to make sure that the information on the invoice-element corresponds to the metadata returned in the JSON-element. Each element is a JSON-Dictionary that holds three key/value-pairs, the webservice call would return 10 invoice elements: companyname invoicenumber projecttitle We will apply the following JSONPath to extract the information for each Dictionary in the list and create an Input table for our Databased-Testcase: JSONPath: $.invoiceElements.* Here we go. We have the input for the Databased Testcase Run Loop. Each column entry is automatically assigned to a Variable that has been created for you. You may use this in call of the second webservice in such a way:","title":"Use case of a query-based valuelist input"},{"location":"conceptual-databasedTestcase/#databased-testcase-run-details","text":"A Databased Testcase run performs the following logic: All Teststeps before the the Data Loop Input Teststep will run once All Teststeps between the Data Loop Input Teststep and the Data Loop Result Teststep will run for each row in the Data Loop Input Teststep Each Teststep defines which of the variables it uses, you may use them in the URL as parameter values or in a JSON or SOAP body The Data Loop Result Teststep is the last Teststep that is run repeatedlly All Teststeps after the Data Loop Result Teststep will run once","title":"Databased Testcase Run Details"},{"location":"conceptual-databasedTestcase/#data-loop-result-teststep","text":"This Teststep gives you the option to write any Variable values in the Test definition hierarchy to a result table. This result table is stored internally and can be exported to a CSV-file. You can append new results to the end of the table with new test runs or simply override any existing entry with the option Append to end of file . See the step-by-step tutorial Create a Databased Testcase for more information how to perform this task.","title":"Data Loop Result Teststep"},{"location":"conceptual-runenvironment/","text":"Run Environment A Run Environment is a logical set of services, applications and configurations that companies use for their software development process to promote development artifacts step-by-step from the local developer machine to production. Examples of a Run Environments A local developer machineo An integrated test environment that developers use to test their components in combination with other connected services, applications and components. A business test environment that business experts use to test software against their business requirements A load and performance test environment> A staging environment with pre-production data Typical properties of Run Environments When you develop or test webservice, you will need to run these tests against several run environments. Some companies may have one or two Run Environments, others may have five to ten. The crucial part of testing is to work with different settings for these Run Environments while keeping the Testcase definition stable. URLs will be different for Run Environments Authentication information may vary , from no or Basic authentication in lower environments, to token or MFA based in higher environments User information for authentication may vary. Users in lower environments may be exchanged by production-similiar users in higher environments. Use Run Environments for your Teststeps Typically you start by importing or creating a service definition (WSDL, Manual HTTP Service). These service definition hold in general all information that are independent of Run Environments. Create an Endpoint reference Create a Manual HTTP Service Definition You might have a list of Service definition like in the screenshot below: You may need to handle several Run Environments like in the next screenshot: You would proceed in the following order: You create Run Environment Service Definitions i.e. you define the environment specific properties for your Service Definitions You link your SOAP and HTTP-Teststeps to Service Definitions to use your Run Environment Service Definitions You pick a Run Environment or run a Test execution and run your tests We will walk through each of these steps below: Create a Run environment Switch to the view Environment and click the Button New Environment This will open a sub dialog where you enter the name of the new Run Environment. Confirm with OK You will see a new entry, which you select to configure the RunEnvironmentServiceDefinitions, if appropriate. You do this, if you want to switch easily between Run Environments and have predefinition URL and authentication settings. We configure the first Manual HTTP Webservice Definition as follows: With this, we can proceed with the last two remain steps in the TestDefinition View: We create an HTTP Teststep and link it to the Manual HTTP Service Definition Create a HTTP Teststep with a Service Definition Reference We can use Run Environments for Teststeps that reference a Service Definition. For SOAP Teststeps this is a mandatory step during creation and mandatory for WSDL-based schema validation, for HTTP Teststeps this is an optional step and very helpful. We switch to the View Service Definition and create a HTTP Teststep that references the My HTTP Service Service Definition. We select the Run Environment Time Travel and open the configuration details for teststep, we are done now. Authentication and base host URL information are kept centrally and referenced only. We can focus on the teststep specific parameters like HTTP Method and a specific route under test, see more about Create an HTTP Teststep and Create a SOAP Teststep .","title":"Run environments"},{"location":"conceptual-runenvironment/#run-environment","text":"A Run Environment is a logical set of services, applications and configurations that companies use for their software development process to promote development artifacts step-by-step from the local developer machine to production.","title":"Run Environment"},{"location":"conceptual-runenvironment/#examples-of-a-run-environments","text":"A local developer machineo An integrated test environment that developers use to test their components in combination with other connected services, applications and components. A business test environment that business experts use to test software against their business requirements A load and performance test environment> A staging environment with pre-production data Typical properties of Run Environments When you develop or test webservice, you will need to run these tests against several run environments. Some companies may have one or two Run Environments, others may have five to ten. The crucial part of testing is to work with different settings for these Run Environments while keeping the Testcase definition stable. URLs will be different for Run Environments Authentication information may vary , from no or Basic authentication in lower environments, to token or MFA based in higher environments User information for authentication may vary. Users in lower environments may be exchanged by production-similiar users in higher environments.","title":"Examples of a Run Environments"},{"location":"conceptual-runenvironment/#use-run-environments-for-your-teststeps","text":"Typically you start by importing or creating a service definition (WSDL, Manual HTTP Service). These service definition hold in general all information that are independent of Run Environments. Create an Endpoint reference Create a Manual HTTP Service Definition You might have a list of Service definition like in the screenshot below: You may need to handle several Run Environments like in the next screenshot: You would proceed in the following order: You create Run Environment Service Definitions i.e. you define the environment specific properties for your Service Definitions You link your SOAP and HTTP-Teststeps to Service Definitions to use your Run Environment Service Definitions You pick a Run Environment or run a Test execution and run your tests We will walk through each of these steps below:","title":"Use Run Environments for your Teststeps"},{"location":"conceptual-runenvironment/#create-a-run-environment","text":"Switch to the view Environment and click the Button New Environment This will open a sub dialog where you enter the name of the new Run Environment. Confirm with OK You will see a new entry, which you select to configure the RunEnvironmentServiceDefinitions, if appropriate. You do this, if you want to switch easily between Run Environments and have predefinition URL and authentication settings. We configure the first Manual HTTP Webservice Definition as follows: With this, we can proceed with the last two remain steps in the TestDefinition View: We create an HTTP Teststep and link it to the Manual HTTP Service Definition","title":"Create a Run environment"},{"location":"conceptual-runenvironment/#create-a-http-teststep-with-a-service-definition-reference","text":"We can use Run Environments for Teststeps that reference a Service Definition. For SOAP Teststeps this is a mandatory step during creation and mandatory for WSDL-based schema validation, for HTTP Teststeps this is an optional step and very helpful. We switch to the View Service Definition and create a HTTP Teststep that references the My HTTP Service Service Definition. We select the Run Environment Time Travel and open the configuration details for teststep, we are done now. Authentication and base host URL information are kept centrally and referenced only. We can focus on the teststep specific parameters like HTTP Method and a specific route under test, see more about Create an HTTP Teststep and Create a SOAP Teststep .","title":"Create a HTTP Teststep with a Service Definition Reference"},{"location":"gettingstarted/","text":"Installing APIJockey TEST and first steps Download Get it on the AppStore: Installation process The installation from the Apple Appstore will work automatically. Once it is installed you'll find APIJockey Test under Applications or in the Launchpad First start of APIJockey TEST When APIJockey TEST launches for the first time, you will be asked to read and accept the license agreement. If you choose to accept them, the main application window opens. A good place to start is the online help APIJockey Test Online help. You need to check that you have read the license agreement and understood and accepted the license agreement before you use the software. Where to start Take a look at the Concents and Create your first tests APIJockey Test feature list This overview gives you an overview of the feature that are currently support. Feature Support in APIJockey TEST WSDL Service definition support Run Environment support Repository support Testset support Testcase support SOAP Teststep HTTP Teststep Datatransfer Teststep XPath Value Providers XQuery Value Providers Text Value Providers ! JSONPath Value Providers Randomize Teststeps Manual Randomized Valuelist Teststeps CSV file-based Randomized Valuelist Teststeps XPath assertions JSONPath assertions JSON assertions SOAP assertions HTTP assertions Databased Testcases Support for CSV file import in Databased Testcases Repository executions Display Repository execution results Testset executions Display Testset execution results Import and export Testcases, Testsets and Repositories","title":"Getting started"},{"location":"gettingstarted/#installing-apijockey-test-and-first-steps","text":"","title":"Installing APIJockey TEST and first steps"},{"location":"gettingstarted/#download","text":"Get it on the AppStore:","title":"Download"},{"location":"gettingstarted/#installation-process","text":"The installation from the Apple Appstore will work automatically. Once it is installed you'll find APIJockey Test under Applications or in the Launchpad","title":"Installation process"},{"location":"gettingstarted/#first-start-of-apijockey-test","text":"When APIJockey TEST launches for the first time, you will be asked to read and accept the license agreement. If you choose to accept them, the main application window opens. A good place to start is the online help APIJockey Test Online help. You need to check that you have read the license agreement and understood and accepted the license agreement before you use the software.","title":"First start of APIJockey TEST"},{"location":"gettingstarted/#where-to-start","text":"Take a look at the Concents and Create your first tests","title":"Where to start"},{"location":"gettingstarted/#apijockey-test-feature-list","text":"This overview gives you an overview of the feature that are currently support. Feature Support in APIJockey TEST WSDL Service definition support Run Environment support Repository support Testset support Testcase support SOAP Teststep HTTP Teststep Datatransfer Teststep XPath Value Providers XQuery Value Providers Text Value Providers ! JSONPath Value Providers Randomize Teststeps Manual Randomized Valuelist Teststeps CSV file-based Randomized Valuelist Teststeps XPath assertions JSONPath assertions JSON assertions SOAP assertions HTTP assertions Databased Testcases Support for CSV file import in Databased Testcases Repository executions Display Repository execution results Testset executions Display Testset execution results Import and export Testcases, Testsets and Repositories","title":"APIJockey Test feature list"},{"location":"pasteboard/","text":"Pasteboard commands These command buttons are used in almost all list view. copy Copies your current selection to a common application pasteboard. This makes the selected elements available for paste operations on the same or any other parent element. With the paste operation, the selected elements are copied to the new parent and kept for the current parent element.- cut Copies your current selection to a common application pasteboard. This makes the selected elements available for paste operations on the same or any other parent element. With the paste operation, the selected elements are moved to the new parent element. paste the elements to the new parent depending on the previous operation (cut,copy). duplicate copies and pastes the selected elements to the current list.","title":"Copy and Paste"},{"location":"pasteboard/#pasteboard-commands","text":"These command buttons are used in almost all list view. copy Copies your current selection to a common application pasteboard. This makes the selected elements available for paste operations on the same or any other parent element. With the paste operation, the selected elements are copied to the new parent and kept for the current parent element.- cut Copies your current selection to a common application pasteboard. This makes the selected elements available for paste operations on the same or any other parent element. With the paste operation, the selected elements are moved to the new parent element. paste the elements to the new parent depending on the previous operation (cut,copy). duplicate copies and pastes the selected elements to the current list.","title":"Pasteboard commands"},{"location":"releasenotes/","text":"Release Notes These release notes cover release information for APIJockey TEST, which is available in the Apple Store for MacOS and also available as a download on APIJockey.com Version 1.6.0 (2024-03-15) This major update contains Display images and PDF-files in response view of HTTP teststeps AI-based Image assertions on text and barcodes within images in the HTTP Teststep assertion list PDF assertions to test for expected text (on pages or the whole document) and PDF document attributes A JSON Tree Editor for HTTP Teststep POST and PUT requests A JSON Tree Viewer for HTTP Teststep Response A new Variable selection dialog to use in the SOAP and JSON Request tree editor Databased Testcases support JSONPath, XQuery and XPath to create input data from Teststeps Bugfix on the structured URL request editor (HTTP Teststep) to resolve characters in URLs appropriately Reworked Testexecution views to display results of historical persisted test runs. Reworked Databased input and result teststep tabular data grid view for better performance on large data sets. The paying Backup and Share functionality is replaced by a personal cloud functionality, which is free of charges. Version 1.5.0 (024-01-20) This major update contains We introduce a cloud-based - paying - solution to Backup and share your Repositories We extended the WSDL import handler to support import of WSDL definitions within a WSDL. Example: XML tree editors allow you to select variables as element contents Version 1.4.0 (2023-11-18) This major update contains A new support for import and export of Testcases, Testsets and Repositories A Transformation sample script to export SOAP tests from SoapUI and ReadyAPI Datatransfer Teststeps provide a new TextValueProvider The HTTP and SOAP Teststep authentication config view allows to set individual prefix names instead of the hardcoded token Bearer Version 1.3.2 (2023-10-16) Bugfix in HTTPRequestEditor and updating logic when selecting teststeps Version 1.3.1 (2023-10-08) HTTPTeststeps support XML and XML/SOAP contents Support for SOAP 1.2 added Manual validation and pretty-print functionality for HTTPTeststeps and SOAPTeststeps (request and response) added Copy and paste error in text editor fixed Version 1.3.0 (2023-08-18) This major update contains Support for Run Environments in HTTP Teststeps, SOAP Teststeps and persisted Test executions Create a set of rows in a Manual RandomizedvaluelistTeststep View Improved handling of date representation in CSV files with preview in View RandomizedValuelistTeststep and when you Create DatabasedTestcase Version 1.2.3 (2023-07-16) A SOAP response view provides a XML tree view with xpath information that can be selected several minor bug fixes for the syntax highlighting text editor (JSON, SOAP, XPATH) Version 1.2.2 (2023-07-04) This update contains Import and export of variables, see Variables Commands Support for light/dark mode changes in the editor New JSONPath assertions for JSON dictionary arrays, see View JSONPath assertion editor Support for selections in readonly text view and pasteboard support Version 1.2.1 (2023-06-15) This update contains bugfixes for the HTTPTeststep Details view minor improvements for the HTTPTeststep Execution view Version 1.2.0 (2023-06-17) This major update contains Create data-based test cases from CSV files or based on manual tables. Store your test case results in external tables and review results in any spreadsheet application Select your XML-elements from your SOAP-Response to get the underlying XPath Version 1.1.0 (2023-03-11) This major update contains Create a Randomized List Teststep with a Manual Table editor Create a Randomized List Teststep with CSV Import Version 1.0.2 (2022-11-14) Support for XQuery Support for HTTP Assertions Version 1.0.2 (2022-10-09) This update contains bugfixes Version 1.0.1 (2022-09-19) This update contains bugfixes Version 1.1 (2022-09-06) This update contains bugfixes SOAP Teststeps HTTP Teststep Randomize Value Teststep Datatransfer Teststep Test executions (Report View) Version 1.0 (2022-09-06) First Release Test hierarchies with Repositories/Testsets/Testcases and Teststeps Testexecutions for reporting in the Standard Edition SOAP Teststeps HTTP Teststep Variables Randomize Value Teststep Datatransfer Teststep Test executions (Report View) JSONPath support XPath support","title":"Release notes"},{"location":"releasenotes/#release-notes","text":"These release notes cover release information for APIJockey TEST, which is available in the Apple Store for MacOS and also available as a download on APIJockey.com","title":"Release Notes"},{"location":"releasenotes/#version-160-2024-03-15","text":"This major update contains Display images and PDF-files in response view of HTTP teststeps AI-based Image assertions on text and barcodes within images in the HTTP Teststep assertion list PDF assertions to test for expected text (on pages or the whole document) and PDF document attributes A JSON Tree Editor for HTTP Teststep POST and PUT requests A JSON Tree Viewer for HTTP Teststep Response A new Variable selection dialog to use in the SOAP and JSON Request tree editor Databased Testcases support JSONPath, XQuery and XPath to create input data from Teststeps Bugfix on the structured URL request editor (HTTP Teststep) to resolve characters in URLs appropriately Reworked Testexecution views to display results of historical persisted test runs. Reworked Databased input and result teststep tabular data grid view for better performance on large data sets. The paying Backup and Share functionality is replaced by a personal cloud functionality, which is free of charges.","title":"Version 1.6.0 (2024-03-15)"},{"location":"releasenotes/#version-150-024-01-20","text":"This major update contains We introduce a cloud-based - paying - solution to Backup and share your Repositories We extended the WSDL import handler to support import of WSDL definitions within a WSDL. Example: XML tree editors allow you to select variables as element contents","title":"Version 1.5.0 (024-01-20)"},{"location":"releasenotes/#version-140-2023-11-18","text":"This major update contains A new support for import and export of Testcases, Testsets and Repositories A Transformation sample script to export SOAP tests from SoapUI and ReadyAPI Datatransfer Teststeps provide a new TextValueProvider The HTTP and SOAP Teststep authentication config view allows to set individual prefix names instead of the hardcoded token Bearer","title":"Version 1.4.0 (2023-11-18)"},{"location":"releasenotes/#version-132-2023-10-16","text":"Bugfix in HTTPRequestEditor and updating logic when selecting teststeps","title":"Version 1.3.2 (2023-10-16)"},{"location":"releasenotes/#version-131-2023-10-08","text":"HTTPTeststeps support XML and XML/SOAP contents Support for SOAP 1.2 added Manual validation and pretty-print functionality for HTTPTeststeps and SOAPTeststeps (request and response) added Copy and paste error in text editor fixed","title":"Version 1.3.1 (2023-10-08)"},{"location":"releasenotes/#version-130-2023-08-18","text":"This major update contains Support for Run Environments in HTTP Teststeps, SOAP Teststeps and persisted Test executions Create a set of rows in a Manual RandomizedvaluelistTeststep View Improved handling of date representation in CSV files with preview in View RandomizedValuelistTeststep and when you Create DatabasedTestcase","title":"Version 1.3.0 (2023-08-18)"},{"location":"releasenotes/#version-123-2023-07-16","text":"A SOAP response view provides a XML tree view with xpath information that can be selected several minor bug fixes for the syntax highlighting text editor (JSON, SOAP, XPATH)","title":"Version 1.2.3 (2023-07-16)"},{"location":"releasenotes/#version-122-2023-07-04","text":"This update contains Import and export of variables, see Variables Commands Support for light/dark mode changes in the editor New JSONPath assertions for JSON dictionary arrays, see View JSONPath assertion editor Support for selections in readonly text view and pasteboard support","title":"Version 1.2.2 (2023-07-04)"},{"location":"releasenotes/#version-121-2023-06-15","text":"This update contains bugfixes for the HTTPTeststep Details view minor improvements for the HTTPTeststep Execution view","title":"Version 1.2.1 (2023-06-15)"},{"location":"releasenotes/#version-120-2023-06-17","text":"This major update contains Create data-based test cases from CSV files or based on manual tables. Store your test case results in external tables and review results in any spreadsheet application Select your XML-elements from your SOAP-Response to get the underlying XPath","title":"Version 1.2.0 (2023-06-17)"},{"location":"releasenotes/#version-110-2023-03-11","text":"This major update contains Create a Randomized List Teststep with a Manual Table editor Create a Randomized List Teststep with CSV Import","title":"Version 1.1.0 (2023-03-11)"},{"location":"releasenotes/#version-102-2022-11-14","text":"Support for XQuery Support for HTTP Assertions","title":"Version 1.0.2 (2022-11-14)"},{"location":"releasenotes/#version-102-2022-10-09","text":"This update contains bugfixes","title":"Version 1.0.2 (2022-10-09)"},{"location":"releasenotes/#version-101-2022-09-19","text":"This update contains bugfixes","title":"Version 1.0.1 (2022-09-19)"},{"location":"releasenotes/#version-11-2022-09-06","text":"This update contains bugfixes SOAP Teststeps HTTP Teststep Randomize Value Teststep Datatransfer Teststep Test executions (Report View)","title":"Version 1.1 (2022-09-06)"},{"location":"releasenotes/#version-10-2022-09-06","text":"First Release Test hierarchies with Repositories/Testsets/Testcases and Teststeps Testexecutions for reporting in the Standard Edition SOAP Teststeps HTTP Teststep Variables Randomize Value Teststep Datatransfer Teststep Test executions (Report View) JSONPath support XPath support","title":"Version 1.0 (2022-09-06)"},{"location":"task-create-testdefinition/","text":"Create an Endpoint Service Definition An Endpoint (reference) contains the webservice definition, technically. For A SOAP webservice this is the WSDL. Short Overview of the task Switch to the endpoint view Create an endpoint and enter the endpoint-wsdl URL Download the WSDL definition View the endpoint definition Next steps If you want to test a SOAP webservice, you need to import the WSDL. This has several reasons APIJockey TEST will read all types, operations, port types, messages and bindings provides these information in a searchable view. The creation of SOAP Teststep will require you to enter a specific operation. This is the base for the schema validation of your request. Create an Endpoint (reference) Start APIJockey TEST in Launchpad You will see the sidebar on the left. On the top just before the colored window handles, you will see the tab bar. When you start APIJockey TEST, the tab Test defintion is selected. Switch to endpoint definition as shown here: This view will be empty when you haven't yet imported a WSDL definition. We will use an WSDL created by the w3c.org consortium which you can find here and load in your browser. http://schemas.xmlsoap.org/ws/2004/09/enumeration/enumeration.wsdl Let's drag the sidebar to the right, this will show the tabs Endpoint , Test Definition and Test Execution Click the Button New Endpoint Reference A new modal dialog comes up. Enter the following URL: http://schemas.xmlsoap.org/ws/2004/09/enumeration/enumeration.wsdl . In general the WSDL is passed as an URL-Parameter, but we take the url as provided. Add the following data: 1 Enter the URL 2 Tab to next textfield to see a default endpoint name 3 Make sure the toggle start download after confirmation is enabled. 4 Confirm the dialog with OK . The Application will download the WSDL data and display a new entry unter Endpoints with the endpoint name you entered. The first part is done. When you select an endpoint and click the tab types you will see the list of XSD files that imported to or included in the WSDL. You can select each of them, read them and search within them When you select an endpoint and click the tab Textview you will see original the WSDL. You can search here as well. Once you have an Endpoint (reference), you will be able to create a SOAP Teststep. You have the option to create SOAP and HTTP-Teststeps without endpoint references; These teststeps will not support WSDL schema definitions and Run Environment settings. See Testdefinition and Run Environment Create a Test definition hierarchy When you work with a large number of webservices, with various releases, you will find it necessary to organize your tests in a structured, hierarchical way. API-Jockey organizes tests in a hierarchy of - Repository lists - Testset lists - Testcase lists and - Teststep lists. Here, we will walk through the creation of such a Test definition hierarchy to get you started. A Repository, see A Testset A Testcase These tree elements are mandatory for creating teststeps. APIJockey TEST provides several types of Teststeps. See more in View Teststep list Create a Repository When you launch APIJockey TEST you will see a number of views. We will walk through some of these views in this tutorial. Click on the button Create new Repository to create a new Repository. This will open a dialog where you must enter the name of the new Repository. We enter the name Enumerations Enter a unique name for the Test Repository. We'll call it Enumerations .Confirm with OK . You can rename the repository at any later point in time. You will get the following view: As you can see the toggle Edit repositories has become available, since there is a repository selected. You use this option, when you need to work on your Repository list. Untoggle the option Edit repositories**, this will disclose the repository list. You can switch between the repository be selection one of them from dropdown list: Create Testset You are ready to create your first Testset. click with your mouse on the Button new Testset . This opens a new dialog, enter folder as the testset name. Select the new testset and make sure, the Testcase/Teststep list is visible. The testcase view shows the testcases associated with the currently selected testset, which is an empty list for now. Create Testcase To create a new Testcase click the + (new Testcase) Drag the lower right edge of the dialog more to the right to get more space for the name. Enter the name Sample Testcase. Confirm with OK . Now, you have a completed Testdefinition hierarchy and can start creating teststeps. You may continue reading with: Create a Databased testcase Create an HTTP Teststep Create a SOAP Teststep Create a Randomize Teststep Create a Tabulardata Valuelist Teststep Create a Manual Valuelist Teststep View Datatransfer Teststep Create an HTTP Teststep A HTTP teststep performs URL requests for various HTTP methods with or without body JSON data. Prerequisites to create an HTTP Teststep Create a Repository Create a Testset Create a Testcase You have selected a testcase Steps to create an HTTP Teststep The globe icon-ed button creates a new HTTP Teststep. This opens a dialog, which asks you to enter a name for the new teststep. Click cancel, if you changed your mind and don't want to create a HTTP teststep any more. When you confirm with OK , the teststep will be created and is visible in the teststep list. See details to configure and run your HTTP Teststep in HTTP Teststep View Learn about using Run Environments in Run Environments Create a SOAP Teststep A SOAP teststep performs sends a SOAP/XML payload (Request) to a specified URL and waits for the SOAP/XML response payload Prerequisites to create a SOAP Teststep Create a Repository Create a Testset Create a Testcase You have selected a testcase Select the new test case. Then move the mouse down to the teststeps list . Click the Button Create new SOAP Teststep Enter a unique teststep name EnumerateOp disclose the soap endpoint operation list for enumeration.wsdl Select EnumerateOp from the list. Confirm the dialog with OK APIJockey TEST has created a starter request for you.Next, move the separator line between request window and Test list window to the left as much as possible (1) and (2) drag the separator line between request and response fully to the right. Now, it may make sense to further increase the request window size. Go the Menu View and toogle Hide Sidebar . This makes the sidebar invisible. Congratulations, you have your first request. In real life, you would have to provide a Service Url in (1) set authentication data or remove basic authentication. Verify the Test step config settings in (3) Run the SOAP Request Review errors in (5) Learn about using Run Environments in Run Environments","title":"Create your first tests"},{"location":"task-create-testdefinition/#create-an-endpoint-service-definition","text":"An Endpoint (reference) contains the webservice definition, technically. For A SOAP webservice this is the WSDL.","title":"Create an Endpoint Service Definition"},{"location":"task-create-testdefinition/#short-overview-of-the-task","text":"Switch to the endpoint view Create an endpoint and enter the endpoint-wsdl URL Download the WSDL definition View the endpoint definition Next steps If you want to test a SOAP webservice, you need to import the WSDL. This has several reasons APIJockey TEST will read all types, operations, port types, messages and bindings provides these information in a searchable view. The creation of SOAP Teststep will require you to enter a specific operation. This is the base for the schema validation of your request.","title":"Short Overview of the task"},{"location":"task-create-testdefinition/#create-an-endpoint-reference","text":"Start APIJockey TEST in Launchpad You will see the sidebar on the left. On the top just before the colored window handles, you will see the tab bar. When you start APIJockey TEST, the tab Test defintion is selected. Switch to endpoint definition as shown here: This view will be empty when you haven't yet imported a WSDL definition. We will use an WSDL created by the w3c.org consortium which you can find here and load in your browser. http://schemas.xmlsoap.org/ws/2004/09/enumeration/enumeration.wsdl Let's drag the sidebar to the right, this will show the tabs Endpoint , Test Definition and Test Execution Click the Button New Endpoint Reference A new modal dialog comes up. Enter the following URL: http://schemas.xmlsoap.org/ws/2004/09/enumeration/enumeration.wsdl . In general the WSDL is passed as an URL-Parameter, but we take the url as provided. Add the following data: 1 Enter the URL 2 Tab to next textfield to see a default endpoint name 3 Make sure the toggle start download after confirmation is enabled. 4 Confirm the dialog with OK . The Application will download the WSDL data and display a new entry unter Endpoints with the endpoint name you entered. The first part is done. When you select an endpoint and click the tab types you will see the list of XSD files that imported to or included in the WSDL. You can select each of them, read them and search within them When you select an endpoint and click the tab Textview you will see original the WSDL. You can search here as well. Once you have an Endpoint (reference), you will be able to create a SOAP Teststep. You have the option to create SOAP and HTTP-Teststeps without endpoint references; These teststeps will not support WSDL schema definitions and Run Environment settings. See Testdefinition and Run Environment","title":"Create an Endpoint (reference)"},{"location":"task-create-testdefinition/#create-a-test-definition-hierarchy","text":"When you work with a large number of webservices, with various releases, you will find it necessary to organize your tests in a structured, hierarchical way. API-Jockey organizes tests in a hierarchy of - Repository lists - Testset lists - Testcase lists and - Teststep lists. Here, we will walk through the creation of such a Test definition hierarchy to get you started. A Repository, see A Testset A Testcase These tree elements are mandatory for creating teststeps. APIJockey TEST provides several types of Teststeps. See more in View Teststep list","title":"Create a Test definition hierarchy"},{"location":"task-create-testdefinition/#create-a-repository","text":"When you launch APIJockey TEST you will see a number of views. We will walk through some of these views in this tutorial. Click on the button Create new Repository to create a new Repository. This will open a dialog where you must enter the name of the new Repository. We enter the name Enumerations Enter a unique name for the Test Repository. We'll call it Enumerations .Confirm with OK . You can rename the repository at any later point in time. You will get the following view: As you can see the toggle Edit repositories has become available, since there is a repository selected. You use this option, when you need to work on your Repository list. Untoggle the option Edit repositories**, this will disclose the repository list. You can switch between the repository be selection one of them from dropdown list:","title":"Create a Repository"},{"location":"task-create-testdefinition/#create-testset","text":"You are ready to create your first Testset. click with your mouse on the Button new Testset . This opens a new dialog, enter folder as the testset name. Select the new testset and make sure, the Testcase/Teststep list is visible. The testcase view shows the testcases associated with the currently selected testset, which is an empty list for now.","title":"Create Testset"},{"location":"task-create-testdefinition/#create-testcase","text":"To create a new Testcase click the + (new Testcase) Drag the lower right edge of the dialog more to the right to get more space for the name. Enter the name Sample Testcase. Confirm with OK . Now, you have a completed Testdefinition hierarchy and can start creating teststeps. You may continue reading with: Create a Databased testcase Create an HTTP Teststep Create a SOAP Teststep Create a Randomize Teststep Create a Tabulardata Valuelist Teststep Create a Manual Valuelist Teststep View Datatransfer Teststep","title":"Create Testcase"},{"location":"task-create-testdefinition/#create-an-http-teststep","text":"A HTTP teststep performs URL requests for various HTTP methods with or without body JSON data.","title":"Create an HTTP Teststep"},{"location":"task-create-testdefinition/#prerequisites-to-create-an-http-teststep","text":"Create a Repository Create a Testset Create a Testcase You have selected a testcase","title":"Prerequisites to create an HTTP Teststep"},{"location":"task-create-testdefinition/#steps-to-create-an-http-teststep","text":"The globe icon-ed button creates a new HTTP Teststep. This opens a dialog, which asks you to enter a name for the new teststep. Click cancel, if you changed your mind and don't want to create a HTTP teststep any more. When you confirm with OK , the teststep will be created and is visible in the teststep list. See details to configure and run your HTTP Teststep in HTTP Teststep View Learn about using Run Environments in Run Environments","title":"Steps to create an HTTP Teststep"},{"location":"task-create-testdefinition/#create-a-soap-teststep","text":"A SOAP teststep performs sends a SOAP/XML payload (Request) to a specified URL and waits for the SOAP/XML response payload","title":"Create a SOAP Teststep"},{"location":"task-create-testdefinition/#prerequisites-to-create-a-soap-teststep","text":"Create a Repository Create a Testset Create a Testcase You have selected a testcase Select the new test case. Then move the mouse down to the teststeps list . Click the Button Create new SOAP Teststep Enter a unique teststep name EnumerateOp disclose the soap endpoint operation list for enumeration.wsdl Select EnumerateOp from the list. Confirm the dialog with OK APIJockey TEST has created a starter request for you.Next, move the separator line between request window and Test list window to the left as much as possible (1) and (2) drag the separator line between request and response fully to the right. Now, it may make sense to further increase the request window size. Go the Menu View and toogle Hide Sidebar . This makes the sidebar invisible. Congratulations, you have your first request. In real life, you would have to provide a Service Url in (1) set authentication data or remove basic authentication. Verify the Test step config settings in (3) Run the SOAP Request Review errors in (5) Learn about using Run Environments in Run Environments","title":"Prerequisites to create a SOAP Teststep"},{"location":"task-create-valuelist-teststeps/","text":"Random test data support Overview APIJockey TEST supports several options to provide random data in our tests: You enter your random data in a table editor where the data is stored inside your test definitions and APIJockey TEST will read a random row during the test run. You provide random value provider configuration i.e. you define simple rules inside a teststep that allows for random data generation You provide a CSV file where a random row will be used during test run. Create a Manual RandomizedValuelist Teststep Creates an empty table of rows and columns and randomizes data in this table to provide variables values. You may edit rows and columns and apply formatting. Steps to create a manual RandomizedValuelist Teststep Select the button create new RandomizedValuelist teststep with manual data entry This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. Cancel dismisses without creating the teststep. When you select the new teststep, the Manual RandomizedValuelist Teststep editor opens. See details to edit the randomized list value in Manual Randomizedvaluelist Teststep View If you have a CSV file that you want to import, you may want to Create a RandomizedValuelist Teststep Create a Randomize Teststep with a Random Value Provider This walkthrough shows you, how to create a Randomizeteststep and define a Randomvalueprovider that provides random, in this case a simplified Vehicle Identification Number (VIN) Step 1: Create a RandomizeTeststep Select the button create new RandomizedValuelist teststep with manual data entry This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. Cancel dismisses without creating the teststep. When you select the new test step, the RandomizeTeststep editor opens. See details to edit the randomized list value in RandomizeTeststep View The RandamizeTeststep displays an empty list of RandomValueProviders and, if selected the editor to configure the random value provider. Step 2: Create a RandomValueProvider for a simplified VIN We want to create ONE RandomValueProvider in this RandomizeTeststep that provides random VINs The VIN: starts with WDB contains 14 subsequent alphanumerical characters We want to store this random VIN in a testcase variable vin , which we need to create. Click with your mouse on the button create new random value and enter the name VIN (Vehicle Identification number). We will create a simplified VIN-generator that is sufficient for our purposes. Select the string random value provider - entry VIN . This opens the StringRandomvalueProvider editor. Click with your mouse on the button create new String random value (#text) . This opens a dialog for the element to be created. Insert the name WDB and confirm with OK . This will insert a new expression value, which we need to select to edit it. When you select your WDB expression, you will see an editor on the right side, with some defaults. We keep them for the moment. Click with your mouse on the button Test your randomValue to see the outcome. The random value is displayed besides the text current random value preview: . this is not yet want we wanted. We set the value expression type to fixed and set the included characters to WDB . and test again our randomValue. Click again with your mouse on the button #text . This opens a dialog for the element to be created. Enter the name VINtail and confirm with OK . This will insert a new element, which we need to select to edit it. Edit the value expression as follows included values ABCDEFGHIJKLMNOP123456789 number of random characters 14 make sure the VINtail comes after the WDB . You may use move up or move down . Click with your mouse on the button Test your randomValue to see the outcome. The random value is displayed besides the text current random value preview: . This would give following result: Step 3: Reference a testcase variable The command Test your random value lets you verify, if the definition works as desired. To use this definition. you must link a variable to the RandomValueProvider. This is done with the VariableValueTransfer view . Let's create this here. We add a new variable with name VIN on the testcase and connect it to our RandomValueProvider. Click with your mouse on Add Variable . A dialog opens where you can edit the name and (optionally) the value. We'll keep the value at it is. Enter the name VIN You will see the new variable. Double click the variable to get the variable connected to your RandomValueProvider When you click Run teststep now, you will see synchronized value for: RandomValueProvider preview the expression list preview the connected variable value. If you want, you can verify the variable value itself in the sidebar navigation, which we may need to make visible first, depending on the current state, you may toggle to show the sidebar here: When the sidebar is visible, you will see the variables list, and in this, you'll find your connected and updated variable. Create a RandomizedValuelist Teststep Takes a CSV file as input and randomizes data in this file to provide variables values. Steps to create a RandomizedValuelist Teststep The RandomizedValuelist Teststep expects a CSV file as input. You will find a sample walkthrough in Steps to create a CSV file with Apple\u00ae Numbers Select the button create new RandomizedValuelist Teststep This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. When you select the new teststep, the RandomizedValuelist Teststep editor opens. See details to configure the randomized list value in Randomizedvaluelist Teststep View If you have a CSV file that you want to import, you may want to [Create a manual RandomizedValuelist Teststep] Steps to create a CSV file with Apple Numbers This short tutorial demonstrates a very basic CSV file that serves as input. It provides a small set of contact information. We assume we have a limited set of data and would like to create randomized combination of the data. e.g. Column 1 - Row 1 with Column 2 Row 7.... We created our limited test data in Apple\u00ae Numbers,but it does not really matter, what source the CSV is created from. We cover Apple\u00ae Numbers here to show how this can done. Export the table Select the menu File Select the menu item Export To Select the sub menu item CSV... This opens a two steps wizard that allows you to customize export settings. Choose CSV Keep include table names unchecked Under Advanced Options make sure, Unicode (UTF-8) is selected Click Next... Select your favorite destination folder. In the screenshot, this is the personal download folder. When you open Finder you will find the CSV file in the folder downloads.","title":"Random test data support"},{"location":"task-create-valuelist-teststeps/#random-test-data-support-overview","text":"APIJockey TEST supports several options to provide random data in our tests: You enter your random data in a table editor where the data is stored inside your test definitions and APIJockey TEST will read a random row during the test run. You provide random value provider configuration i.e. you define simple rules inside a teststep that allows for random data generation You provide a CSV file where a random row will be used during test run.","title":"Random test data support Overview"},{"location":"task-create-valuelist-teststeps/#create-a-manual-randomizedvaluelist-teststep","text":"Creates an empty table of rows and columns and randomizes data in this table to provide variables values. You may edit rows and columns and apply formatting.","title":"Create a Manual RandomizedValuelist Teststep"},{"location":"task-create-valuelist-teststeps/#steps-to-create-a-manual-randomizedvaluelist-teststep","text":"Select the button create new RandomizedValuelist teststep with manual data entry This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. Cancel dismisses without creating the teststep. When you select the new teststep, the Manual RandomizedValuelist Teststep editor opens. See details to edit the randomized list value in Manual Randomizedvaluelist Teststep View If you have a CSV file that you want to import, you may want to Create a RandomizedValuelist Teststep","title":"Steps to create a manual RandomizedValuelist Teststep"},{"location":"task-create-valuelist-teststeps/#create-a-randomize-teststep-with-a-random-value-provider","text":"This walkthrough shows you, how to create a Randomizeteststep and define a Randomvalueprovider that provides random, in this case a simplified Vehicle Identification Number (VIN)","title":"Create a Randomize Teststep with a Random Value Provider"},{"location":"task-create-valuelist-teststeps/#step-1-create-a-randomizeteststep","text":"Select the button create new RandomizedValuelist teststep with manual data entry This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. Cancel dismisses without creating the teststep. When you select the new test step, the RandomizeTeststep editor opens. See details to edit the randomized list value in RandomizeTeststep View The RandamizeTeststep displays an empty list of RandomValueProviders and, if selected the editor to configure the random value provider.","title":"Step 1: Create a RandomizeTeststep"},{"location":"task-create-valuelist-teststeps/#step-2-create-a-randomvalueprovider-for-a-simplified-vin","text":"We want to create ONE RandomValueProvider in this RandomizeTeststep that provides random VINs The VIN: starts with WDB contains 14 subsequent alphanumerical characters We want to store this random VIN in a testcase variable vin , which we need to create. Click with your mouse on the button create new random value and enter the name VIN (Vehicle Identification number). We will create a simplified VIN-generator that is sufficient for our purposes. Select the string random value provider - entry VIN . This opens the StringRandomvalueProvider editor. Click with your mouse on the button create new String random value (#text) . This opens a dialog for the element to be created. Insert the name WDB and confirm with OK . This will insert a new expression value, which we need to select to edit it. When you select your WDB expression, you will see an editor on the right side, with some defaults. We keep them for the moment. Click with your mouse on the button Test your randomValue to see the outcome. The random value is displayed besides the text current random value preview: . this is not yet want we wanted. We set the value expression type to fixed and set the included characters to WDB . and test again our randomValue. Click again with your mouse on the button #text . This opens a dialog for the element to be created. Enter the name VINtail and confirm with OK . This will insert a new element, which we need to select to edit it. Edit the value expression as follows included values ABCDEFGHIJKLMNOP123456789 number of random characters 14 make sure the VINtail comes after the WDB . You may use move up or move down . Click with your mouse on the button Test your randomValue to see the outcome. The random value is displayed besides the text current random value preview: . This would give following result:","title":"Step 2: Create a RandomValueProvider for a simplified VIN"},{"location":"task-create-valuelist-teststeps/#step-3-reference-a-testcase-variable","text":"The command Test your random value lets you verify, if the definition works as desired. To use this definition. you must link a variable to the RandomValueProvider. This is done with the VariableValueTransfer view . Let's create this here. We add a new variable with name VIN on the testcase and connect it to our RandomValueProvider. Click with your mouse on Add Variable . A dialog opens where you can edit the name and (optionally) the value. We'll keep the value at it is. Enter the name VIN You will see the new variable. Double click the variable to get the variable connected to your RandomValueProvider When you click Run teststep now, you will see synchronized value for: RandomValueProvider preview the expression list preview the connected variable value. If you want, you can verify the variable value itself in the sidebar navigation, which we may need to make visible first, depending on the current state, you may toggle to show the sidebar here: When the sidebar is visible, you will see the variables list, and in this, you'll find your connected and updated variable.","title":"Step 3: Reference a testcase variable"},{"location":"task-create-valuelist-teststeps/#create-a-randomizedvaluelist-teststep","text":"Takes a CSV file as input and randomizes data in this file to provide variables values.","title":"Create a RandomizedValuelist Teststep"},{"location":"task-create-valuelist-teststeps/#steps-to-create-a-randomizedvaluelist-teststep","text":"The RandomizedValuelist Teststep expects a CSV file as input. You will find a sample walkthrough in Steps to create a CSV file with Apple\u00ae Numbers Select the button create new RandomizedValuelist Teststep This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. When you confirm with OK the dialog disappears and creates a new entry in the teststep list. When you select the new teststep, the RandomizedValuelist Teststep editor opens. See details to configure the randomized list value in Randomizedvaluelist Teststep View If you have a CSV file that you want to import, you may want to [Create a manual RandomizedValuelist Teststep]","title":"Steps to create a RandomizedValuelist Teststep"},{"location":"task-create-valuelist-teststeps/#steps-to-create-a-csv-file-with-apple-numbers","text":"This short tutorial demonstrates a very basic CSV file that serves as input. It provides a small set of contact information. We assume we have a limited set of data and would like to create randomized combination of the data. e.g. Column 1 - Row 1 with Column 2 Row 7.... We created our limited test data in Apple\u00ae Numbers,but it does not really matter, what source the CSV is created from. We cover Apple\u00ae Numbers here to show how this can done.","title":"Steps to create a CSV file with Apple Numbers"},{"location":"task-create-valuelist-teststeps/#export-the-table","text":"Select the menu File Select the menu item Export To Select the sub menu item CSV... This opens a two steps wizard that allows you to customize export settings. Choose CSV Keep include table names unchecked Under Advanced Options make sure, Unicode (UTF-8) is selected Click Next... Select your favorite destination folder. In the screenshot, this is the personal download folder. When you open Finder you will find the CSV file in the folder downloads.","title":"Export the table"},{"location":"task-createdatabasedtestcase/","text":"Create a Databased Testcase This walkthrough shows you, how to create a Databased Testcase with a manual input table. You will perform the following steps: use and edit manual input table create a simple REST-Service call create variable transfers for the result teststep download the result table Create the Test Definition Hierarchy Create a Repository Create a Testset You have selected a testset Step 1: Create a Databased Testcase Select the button create new Databased Testcase This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. (storage/DialogNewDatabasedTestcase. When you confirm with OK the dialog disappears and creates a new entry in the testcase list. Cancel dismisses without creating the testcase. When you select the new testcase, you will see two teststeps that were created automatically for you (storage/DatabasedTestcaseAftercreation.)/> The Data Loop Input Teststep that you will use later to enter data. The Data Loop Result Teststep that you will use later to set result values. Step 2: Create a HTTP Teststep We will create a new HTTP Teststep Click on the button Create new HTTP teststep . This will open a dialog where you enter the name Search iTunes and confirm with OK This has created a new HTTP Teststep that will appear at the top of the list.. We will configure this teststep further down in the tutorial. The Databased Testcase runs all teststeps between the input teststep and output testsep in a loop that is determined by the number of elements in the Input Teststep and limited to the position of the Result Teststep where you may document the results in an exportable table. This means, we want the new Teststep to be between the Input Teststep and the Result Teststep . The following screenshot shows how you can rearrange selected teststeps with the arrow buttons to move the Search iTunes HTTP Teststep between Input Testsstep and Result Teststep We will use the real-life iTunes Search API. The documentation of this API is provided here on iTunes Search API Documentation Archive Please don't understand these screenshots as any kind of endorsement from Apple\u00ae for this software. You may use the following request in an application that wants to retrieve a list of apps. We will use one sample request from the iTuneSearchAPI documentation, and include a limit of five results: To search for applications titled \u201cYelp\u201d and return only the results from th e United States iTunes Store, use the following URL: https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 When you use the same request with the same parameters, you may more easily follow the instructions and assertion results used in this tutorial. So even if your favorite app isn't the one mentioned above it's worth using it for this tutorial. Step 3: Edit the Data Loop Input Teststep We want to demonstrate the Databased Testcase by providing variations of: Limit 1, 2, 3 (As the intention of the Search API is not to help out with our tutorial, we want to limit the search results) Country (US, Canada) Software (Yelp, Apple) These variations are sufficient to demonstrate how the Databased Testcase works. Step 4: Enter the Input teststep data with a manal list The APIJockey TEST Community Edition allows you to enter test data in an internal table editor. The Apple Appstore Edition allows you the import a CSV-file. As we have few elements only, we will use the manual table editor. Select the Teststep Data Loop Input Teststep and make sure your App shows the same view as in the screenshot below: We need to see: The variables of the testcase The selected Databased Testcase The selected Data Loop Input Teststep The (empty) columns of the inline table The (empty) rows of the inline table We will create a table with the following columns, according to the variations for the URL that we want to demonstrate: Limit Country Software The Data Loop Input Teststep we automatically create Variables for us that we can use in the parameter list of our URL To create a column, click the button Add new Column This will open a dialog where you enter the name of the column ( = variable name ) and confirm with OK . We will create to other columns with the name Country and Software and select the column Software . We should have the following contents: We have three columns (Limit, Country, Software) We have three variables on the testcase (Limit, Country, Software), the variable link is editable, but we are happy with the default. We have not yet any contents for the variables, which we will do next: We will create the following new table contents: Limit Country Softwre 1 US Apple 2 CA Apple 3 US Yelp After entering the table, select the second row und click the Run Button. this will give the following results: ![Screenshot Databased Testcase DataLoopInputteststep after rows added and run.png)(storage/DatabasedTestcaseDataLoopInputteststepAfterRowsAddedAndRun.png) With this configuration in place, you can easily create new rows, which is not required for the tutorial. Select a specific row if you want to test manually a specific row. Step 5: Edit the URL and run the Search iTunes HTTP Teststep We select the teststep Search iTunes and copy the URL in the URL textfield https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 We can disclose the Sidebar and the Test definition list (Testcase, Teststep) and focus on our current teststep, for now. We run the teststep and will get a JSON Response as in this sceenshot: (storage/DatabasedTestcaseHTTPTeststepWithfixedURL.) ![Databased Testcase HTTPTeststep with fixed URL] Now, we will replace the fixed parameter with variable placeholders: old: https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 new: https://itunes.apple.com/search?term=$(Testcase.Software)&country=$(Testcase.Country)&entity=software&limit=$(Testcase.Limit) We will see this outcome: This works, but the URL is hard to edit, you may switch to a different URL edit, like URL with separate list of query parameters ![Databased Testcase HTTPTeststep with variable URL query parameter list.png)(storage/DatabasedTestcaseHTTPTeststepWithVariableURLQueryParameterList.png) Step 6: Edit and run the DataLoop Result Teststep We want to store some information from the HTTP request to a result teststep to assess the loop results in table later. This may be any spreadsheet application, such as Numbers or Excel. The approach is, you can use any variable value on the Teststep, Testcase, Testset or Repository and each loop will result in a new row in the result table. This result table can be exported to CSV and thus be imported to large set of external applications. For this tutorial, we would like to store: Limit Country Software Use may use a Datatransfer Teststep to include further data and access them via their link variables. We select the DataLoop ResultTeststep as shown below: We create the first new column Limit .Click on the button New Column . This will open a dialog where you can enter the name Limit and confirm with OK . Select the column, you will see a view where you can link any variable within the current test definition hierarchy (teststep, testcase, testset, repository) to the new column. Click on the variable Limit to link this testcase variable to the selected column.This will show the linked variable. !(storage/DatabasedTestcaseDataLoopResulTeststepColumnLimitOnly.png) We create two more columns and link them with the existing testcase variables that share their name. This will result in the following column-variable-data, assuming, you had selected the second row in the DataLoopInputTeststep and you pressed the Run button. Limit Country Software 1 US Apple 2 CA Apple 3 US Yelp Run the Databased Testcase and the DataLoopResultTeststep When we run this teststep with the Run button, the current set of columns will be added with their linked variable values to the result table. The toggle Append to end of table is set to true. Press (optionally the delete button to remove the result row from the teststep run. We won't do it here. Finally, we will run the DatabasedTestcase itself in the Testcase List View and see how this testcase iterates of the rows of the DataLoopInputTeststep.Make sure, the toggle Append to end of table is set to true in the result table. After we click the Run button on the testcase list view with the Databased Testcase selected, we see that the test run iterates of the rows in the input table. Finally, we have three more rows in the result table. We hope this tutorial was helpful and you enjoy using APIJockey TEST.","title":"Create databased testcase"},{"location":"task-createdatabasedtestcase/#create-a-databased-testcase","text":"This walkthrough shows you, how to create a Databased Testcase with a manual input table. You will perform the following steps: use and edit manual input table create a simple REST-Service call create variable transfers for the result teststep download the result table","title":"Create a Databased Testcase"},{"location":"task-createdatabasedtestcase/#create-the-test-definition-hierarchy","text":"Create a Repository Create a Testset You have selected a testset","title":"Create the Test Definition Hierarchy"},{"location":"task-createdatabasedtestcase/#step-1-create-a-databased-testcase","text":"Select the button create new Databased Testcase This opens a dialog that allows you to enter the name of the teststep. You can choose to enter this name at any point later in time. (storage/DialogNewDatabasedTestcase. When you confirm with OK the dialog disappears and creates a new entry in the testcase list. Cancel dismisses without creating the testcase. When you select the new testcase, you will see two teststeps that were created automatically for you (storage/DatabasedTestcaseAftercreation.)/> The Data Loop Input Teststep that you will use later to enter data. The Data Loop Result Teststep that you will use later to set result values.","title":"Step 1: Create a Databased Testcase"},{"location":"task-createdatabasedtestcase/#step-2-create-a-http-teststep","text":"We will create a new HTTP Teststep Click on the button Create new HTTP teststep . This will open a dialog where you enter the name Search iTunes and confirm with OK This has created a new HTTP Teststep that will appear at the top of the list.. We will configure this teststep further down in the tutorial. The Databased Testcase runs all teststeps between the input teststep and output testsep in a loop that is determined by the number of elements in the Input Teststep and limited to the position of the Result Teststep where you may document the results in an exportable table. This means, we want the new Teststep to be between the Input Teststep and the Result Teststep . The following screenshot shows how you can rearrange selected teststeps with the arrow buttons to move the Search iTunes HTTP Teststep between Input Testsstep and Result Teststep We will use the real-life iTunes Search API. The documentation of this API is provided here on iTunes Search API Documentation Archive Please don't understand these screenshots as any kind of endorsement from Apple\u00ae for this software. You may use the following request in an application that wants to retrieve a list of apps. We will use one sample request from the iTuneSearchAPI documentation, and include a limit of five results: To search for applications titled \u201cYelp\u201d and return only the results from th e United States iTunes Store, use the following URL: https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 When you use the same request with the same parameters, you may more easily follow the instructions and assertion results used in this tutorial. So even if your favorite app isn't the one mentioned above it's worth using it for this tutorial.","title":"Step 2: Create a HTTP Teststep"},{"location":"task-createdatabasedtestcase/#step-3-edit-the-data-loop-input-teststep","text":"We want to demonstrate the Databased Testcase by providing variations of: Limit 1, 2, 3 (As the intention of the Search API is not to help out with our tutorial, we want to limit the search results) Country (US, Canada) Software (Yelp, Apple) These variations are sufficient to demonstrate how the Databased Testcase works.","title":"Step 3: Edit the Data Loop Input Teststep"},{"location":"task-createdatabasedtestcase/#step-4-enter-the-input-teststep-data-with-a-manal-list","text":"The APIJockey TEST Community Edition allows you to enter test data in an internal table editor. The Apple Appstore Edition allows you the import a CSV-file. As we have few elements only, we will use the manual table editor. Select the Teststep Data Loop Input Teststep and make sure your App shows the same view as in the screenshot below: We need to see: The variables of the testcase The selected Databased Testcase The selected Data Loop Input Teststep The (empty) columns of the inline table The (empty) rows of the inline table We will create a table with the following columns, according to the variations for the URL that we want to demonstrate: Limit Country Software The Data Loop Input Teststep we automatically create Variables for us that we can use in the parameter list of our URL To create a column, click the button Add new Column This will open a dialog where you enter the name of the column ( = variable name ) and confirm with OK . We will create to other columns with the name Country and Software and select the column Software . We should have the following contents: We have three columns (Limit, Country, Software) We have three variables on the testcase (Limit, Country, Software), the variable link is editable, but we are happy with the default. We have not yet any contents for the variables, which we will do next: We will create the following new table contents: Limit Country Softwre 1 US Apple 2 CA Apple 3 US Yelp After entering the table, select the second row und click the Run Button. this will give the following results: ![Screenshot Databased Testcase DataLoopInputteststep after rows added and run.png)(storage/DatabasedTestcaseDataLoopInputteststepAfterRowsAddedAndRun.png) With this configuration in place, you can easily create new rows, which is not required for the tutorial. Select a specific row if you want to test manually a specific row.","title":"Step 4: Enter the Input teststep data with a manal list"},{"location":"task-createdatabasedtestcase/#step-5-edit-the-url-and-run-the-search-itunes-http-teststep","text":"We select the teststep Search iTunes and copy the URL in the URL textfield https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 We can disclose the Sidebar and the Test definition list (Testcase, Teststep) and focus on our current teststep, for now. We run the teststep and will get a JSON Response as in this sceenshot: (storage/DatabasedTestcaseHTTPTeststepWithfixedURL.) ![Databased Testcase HTTPTeststep with fixed URL] Now, we will replace the fixed parameter with variable placeholders: old: https://itunes.apple.com/search?term=yelp&country=us&entity=software&limit=5 new: https://itunes.apple.com/search?term=$(Testcase.Software)&country=$(Testcase.Country)&entity=software&limit=$(Testcase.Limit) We will see this outcome: This works, but the URL is hard to edit, you may switch to a different URL edit, like URL with separate list of query parameters ![Databased Testcase HTTPTeststep with variable URL query parameter list.png)(storage/DatabasedTestcaseHTTPTeststepWithVariableURLQueryParameterList.png)","title":"Step 5: Edit the URL and run the Search iTunes HTTP Teststep"},{"location":"task-createdatabasedtestcase/#step-6-edit-and-run-the-dataloop-result-teststep","text":"We want to store some information from the HTTP request to a result teststep to assess the loop results in table later. This may be any spreadsheet application, such as Numbers or Excel. The approach is, you can use any variable value on the Teststep, Testcase, Testset or Repository and each loop will result in a new row in the result table. This result table can be exported to CSV and thus be imported to large set of external applications. For this tutorial, we would like to store: Limit Country Software Use may use a Datatransfer Teststep to include further data and access them via their link variables. We select the DataLoop ResultTeststep as shown below: We create the first new column Limit .Click on the button New Column . This will open a dialog where you can enter the name Limit and confirm with OK . Select the column, you will see a view where you can link any variable within the current test definition hierarchy (teststep, testcase, testset, repository) to the new column. Click on the variable Limit to link this testcase variable to the selected column.This will show the linked variable. !(storage/DatabasedTestcaseDataLoopResulTeststepColumnLimitOnly.png) We create two more columns and link them with the existing testcase variables that share their name. This will result in the following column-variable-data, assuming, you had selected the second row in the DataLoopInputTeststep and you pressed the Run button. Limit Country Software 1 US Apple 2 CA Apple 3 US Yelp","title":"Step 6: Edit and run the DataLoop Result Teststep"},{"location":"task-createdatabasedtestcase/#run-the-databased-testcase-and-the-dataloopresultteststep","text":"When we run this teststep with the Run button, the current set of columns will be added with their linked variable values to the result table. The toggle Append to end of table is set to true. Press (optionally the delete button to remove the result row from the teststep run. We won't do it here. Finally, we will run the DatabasedTestcase itself in the Testcase List View and see how this testcase iterates of the rows of the DataLoopInputTeststep.Make sure, the toggle Append to end of table is set to true in the result table. After we click the Run button on the testcase list view with the Databased Testcase selected, we see that the test run iterates of the rows in the input table. Finally, we have three more rows in the result table. We hope this tutorial was helpful and you enjoy using APIJockey TEST.","title":"Run the Databased Testcase and the DataLoopResultTeststep"},{"location":"teststepconfigviews/","text":"Application Overview When you open APIJockey TEST you will see this layout: View Variables The Variables view consists actually of four views that allow to manage variables on different test definition elements. Repository Testset Testcase Teststep The status of the variables views and their visibility depends - of course - of your current selection. Base Variable View The Variable views have all the same structure they just differ in the variable type and their parent type. The Variables parent selector tabs depend on your current selection. In the above screenshot, there are four tabs visible (repository, testset, testcase and teststep). You can deselect a repostory without losing the selection of the underlying testset. The name below the variables parent selector tabs is the name of parent element you have selected with your tabs, in this case the teststep Enumerate , as you can see on the right. Commands Show/hide variables toggles the variables list. This may be helpful to have more space when editing testsets and repositories Export all variables will prompt for a directory and creates a properties file (key/value, separated by = ) for all visible variable parents Import variables will prompt for a properties file (see above) contents and read the values as String variables Export variables will prompt for file name and location and creates a properties file (see above) Create new variable opens the variables editor as described above Delete selected variables deletes these variables. Edit a selected variable allows you to change the variable type, the name and the value Documentation of the Pasteboard commands Variables editor As described in Concepts , variables represent various value types and can be formatted in many ways. This paragraph walks through the variable editor options Variable types String Variables Enter arbitrary-length Text. No formatting occurs. Password Variables Editor Enter arbitrary-length Text. No formatting occurs. The variable list will not show the variable value. The varaible value will not be shown with the toggle on off (storage/Variables-Editor-passwordvalue-undisclosed.png) ![Variables editor password value undisclosed] To see the actual password value, set the toggle to on (storage/Variables-Editor-passwordvalue-disclosed.png) ![Variables editor password value disclosed] Fixed Date Variables Editor The fixed/static date variables editor uses the builtin date picker to select a date and a time. The editor defaults the formatting to yyyy-mm-dd, but you can apply any supported formatting like yyyy-mm-dd'T'HH:mm:ss Relative Date Variables Editor The relative date variables editor uses the builtin date/time picker to select a date, and if required a time. The editor defaults the formatting to yyyy-mm-dd, but you can apply any supported formatting like yyyy-mm-dd'T'HH:mm:ss. The reevaluation occurs whenever the variables value is accessed, so even in the variables list, this value is reevaluted when the list view updates. Number Variables Editor Number formatting is another frequent requirement as SOAP Webservices expect an identifiable number formatting and schema are pretty strict with the provided formatting. In general they expect simple numbers though. Boolean Variables Editor The Editor supports two options true/false yes/no Run environment Variables As described in [View Run Environment]{#viewrunenvironment} you can configure authentication for a Webservice in a Run Environment Configuration. Data that is configured here, will be accessed, when the user selects the corresponding Run Environment. When you want to access these information within your request, you can provide these values through Run Environment Variables, as described here: Authentication type Textfield name Variable notation in Test definition HTTP basic Authentication HTTP username $(EnvironmentConfig.httpUsername) HTTP basic Authentication HTTP password $(EnvironmentConfig.httpPassword) HTTP bearer Authentication HTTP bearer token $(EnvironmentConfig.bearerToken) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadUsername) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadPassword) None (No HTTP authentication) Payload OTP $(EnvironmentConfig.payloadOTP) None (No HTTP authentication) Payload Token $(EnvironmentConfig.payloadToken) We want to illustrate this specific variable resolution mechanism with the example of a sample request that needs to provide a username, a password, an OTP (fixed) in the Test Run Environment and a Token variable, that is retrieved from another request ) We configure a Service Definition for the local Run Environment with NONE-Authentication which means we will use an Idenity Service and pass over data. The relevant input is highlighted in blue, you will notice the variable value for the payloadToken information. We will pass the four information in an HTTP request (which could be a SOAP request as well. We have set the Run Environment to localhost . Notice the Repository variable with name token .Our request looks like this: Now, we switch to the tab resolvedRequest to see what the variables are resolve to: VariableValueTransfer A VariableValueTransfer designates a value (random value, manual or CSV-file input XPATH-expression JSONPath-expression) to a variable. It also server to write Variable values to a result table. When you want to use dynamic data in your requests, you will always access variable. The origin of the variable data is abstracted in the access and the VariablesValueTransfer describes this data transfer. Configure a VariableValueTransfer When you work with any of these teststeps, you will have to handle the included VariableValueTransfer: View RandomizeTeststep View RandomizedvaluelistTeststep View Manual RandomizedvaluelistTeststep View DatatransferTeststep Conceptual overview of Databased Testcases A variable can be referenced, if it is defined within the teststeps' Test definition Hierarchy on the teststep on the teststep's parent testcase on the teststeps's parent testset on the teststeps's parent repository When you create a new value provider, the variable's parent type is defaulted to testcase . If you want to change this, click with your mouse on the button remove configuration . We will keep the setting as defaulted. Click with your mouse on the button Add Variable . This will open a dialog. Enter the name vin and keep the value as it is. If you switch the tab to something else than String (variable type), this entry will not be visible. Cconfirm with OK You will see a new entry. Click with your mouse on this list entry. Now, the variable is reference, you shoud see the following view. The random value provider is fully configured. You can run your value provider, now. Click with your mouse the on the button test run value provider . the updated value appears in the reference the reference variable view The random value in the screenshot will probably be different from the one you see.. You can reference your variable in the requesteditor as: $(Testcase.vin) View Run Environment this view can be found in the Viewgroup Environment The conceptual overview of working with different environments can be found in Run Environment Find a detailed description of the Run Environment View here List of Run Environments list of environments displays all environments. Environments allow a service related configuration for URLs and authentication information new Environment creates a new entry delete removes an environment rename lets you change the list display name, which also affects the Run Environment picker text in the Viewgroup Testdefinition move up the position of the selected entries move down the position of the selected entries copy an existing entry to create a new entry Run Environment configurations for a Service Definition When you select en entry you can configure Run Environment specific settings, either empty ![screenshot Run Environment with empty Service Configuration] (storage/RunEnvironmentEmptyConfiguration.png) Add will create a new configuration for the selected Run Environment time travel on the Service Definition My HTTP Service two When you click Add you will see a configuration dialog, outlined with screenshot for an existing configuration on another Service Definition: (storage/RunEnvironmentServiceDefinition.png) ![screenshot Run Environment Service Definition] This is a screenshot from a Manual HTTP Service Definition Run Environment configuration for an environment time travel . The SOAP definition differs only in the URL input, which is described below. Settings for Run Environment Service Definitions On the top, you see the currently seelcted run environment name You enter the host url and the port for a Manual HTTP Service Definition or a complete URL for SOAP Service. We expect non-SOAP Service to use routes and query parameters added to the host url that will not differ between environments but teststep specific, where soap service have just different URLs without route and query parameters Authentication has three options: Basic HTTP Authentication, you provide a username and a password which will be used to create the HTTP Header Authorization Basic . See the example configuration in the screenshot above Bearer HTTP Authentication, you provide a token information which will be used to create a HTTP Header Authorization Bearer NO HTTP Authentication, you may provide a payload username a payload password , a payload OTP ** and/or a payload token** that may be static or be variable Resolution process for Run Environment settings See Run Environment for the conceptual overview. In the case of basic and bearer authentication, APIJockey Test handles adding the Headers for you. It will resolve the information entered in this configuration screenshot. You can access the authentication information in your payload by using variables, in the case you need to authentication against an Identity Service to get authorized for a business service You can use variables in the configuration, if you need to run an authentication call and want to store a token in a repository variable. For convenience, find all EnvironmentConfig Variables here with the notation to use in your Test Definition Authentication type Textfield name Variable notation in Test definition HTTP basic Authentication HTTP username $(EnvironmentConfig.httpUsername) HTTP basic Authentication HTTP password $(EnvironmentConfig.httpPassword) HTTP bearer Authentication HTTP bearer token $(EnvironmentConfig.bearerToken) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadUsername) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadPassword) None (No HTTP authentication) Payload OTP $(EnvironmentConfig.payloadOTP) None (No HTTP authentication) Payload Token $(EnvironmentConfig.payloadToken) SOAP Attachments The SOAP Request editor provides a tab Attachments to edit, update and delete attachments Command overview Create new attachment adds a new enty in the attachments list. You need to load the actual content later, as in the screenshot. Delete removes the selected attachments from the attachments list. The local file disc content is not removed. Rename lets you change the name of the selected attachment. The attachment name is not used in the request and helps you organize your attachment list. Move Up changes the order of the selected attachment entries. This has not impact on the request Move Down changes the order of the selected attachment entries. This has not impact on the request Load from disc opens a file open dialog where you can select the file to attach. Select and confirm will load the file contents and insert them to the attachment entry, It will try to recognizes the appropriate MIME type. Edit MIME type lets you set your own MIME type that is uses in the request Create a new attachment Click with your mouse on the button Create new attachment . This will open a new dialog. ![Dialog new SOAPRequestAttachment] (storage/Dialogs-NewSOAPRequestAttachment.png) Enter the name (e.g. invoice) and confirm with OK. This will create a new attachment as in the screenshot above. Click with your mouse on the button Load from disc to insert the local file contents. In the screenshot this is an invoice that should be sent with request to test an upload functionality. The content is - if supported - in the content preview Supported Type s The builtin attachments preview supports: PDF-Documents Images Text If the content type is different, no preview is shown, the attachment will still be sent with the request. Reference attachments If you want to reference the attachment in the request editor, click with your mouse on the button Copy to Pasteboard . The Pasteboard will contain a string like so: $(Attachment.CID:8FD11DF7-5DE5-49FD-A6A8-D1C7B1DB6A83@apijockey.com). You can copy this text in any element like in the screenshot for the element msg:Data Assertion editors HTTP assertion editor An HTTP assertion verifies basic HTTP-URL request specific information. HTTP Assertions are available for both HTTP Teststep and SOAP Teststep . Assertion value Currently, there are three different data, that can be assessed: Status (HTTP Status) Data length (Binary data length) Response time (measured in ms) Assertion test type The assertion test type depends on the value type being assessed. For HTTP assertions these are integer values, so the assertion test type provides a set of options that make sense for integers. is equal to (single expected value) is smaller than (single expected value) is greater than (single expected value) is between ... and ... is not between ... and ... is in List Expected value The expected value depends on the assertion test type and is either: single expected value a lower range limit and an upper range limit a list of values Run assertion Run assesses the current response data against the assertion test type, the expected value and the actual value. The actual HTTP values are kept in memory, so you can rerun a test as often as you want and change it. Image Assertion editor An Image assertion uses a trained machine learning model to capture the text contents of a file. Query Type As a first step, you need to configure, where the image data should be taken from. There are four options: JSONPath , enter the JSONPath expression to the binary data in the response that represents the image. XPath 1 (with function support) , enter the XPath expression to the binary data that represents the image. Note: If you work with MTOM, you will need to select the href attribute which holds the content-ID reference.** XQuery / XPath 2 (no function support), enter the XPath expression to the binary data that represents the image. Plain Document data, the response is expected to hold binary data that represent the image. Configure your Image assertion You have three options to check Text content on an image Contains text enter the expected text. Contains text (ignore case), enter the expected text. Barcode , enter the expected payload The blue run button together with the result status (green checkmark) validates the assertion and gives you immediate feedback. Preview When you run the query (blue run button), APIJockey TEST will try to read the Image data, supported types are TIFF, PNG, JPEG, GIF and PDF. IF this is successful you will see the received image in the preview, together with the assertion run results as in the screenshot below: Query result It seems odd that both preview and response view show the same content. This is the case as the response contains the image only. In other cases you might have a JSON Response or a SOAP Response and would apply JSONPath, XQuery or XPath to extract the Base64 encoded data, which would then internally be transformed to binary image data. If this is the case, you will see another tab Query Result that should help you identify, what part of the response document is returned by your query. Text/Barcode identification When the assertion run is completed you will see a tab Text identification or Barcode identification depending on your Assertion type. This tab holds a list of Texts / Barcode payload found during the AI-scan together with a confidence vote. This can help you decide, if you want to run the assertion automatically or manually only, as a low confidence vote might be an indicator for a hit that is on reliably reproduceable. Also keep in mind that ML-model are non-deterministic. In our sample, the text identification gives these results: JSON assertion editor The JSON assertion editor allows you to configure and run assertions against JSON response data with JSONPath. JSONPath can return a single (complex) value or a list of values. JSONPath editor with expression Writing assertions can be cumbersome if you need to work with several query languages, like SQL, JSONPath and XPath to mention some of them. APIJockey TEST supports you with a large set of predefined queries that can apply on your JSON objects. The idea is to let you query the JSON objects with a small subset of JSONPath expressions and assert these objects in various ways by configuring what you actually want to test. A JSON assertion expects a valid JSONPath expression. You may enter you assertion here. The JSONPath assertion will be executed against the current response. In case of errors, these will be displayed in the editor. Expected return type When you edit a JSONPath Expression, you need to select the type of return value that you expect. We will use this information to provide an appropriate set of assertion test types: The JSON assertion in the above screenshot selects a list of prices. Thus, the expected return type is set to list of floating values. You have the following list of expected return types: Return types that expect one value The assertion will fail, if the expected return type does not equal the actual return type, e.g. expected: List of booleans, actual: single boolean. The assertion type determines the way the assertion is verified: Boolean value true false Date with formatting Date is day of run date Date is not nil Date is nil/null or not present Date is equal expected day Date has equal distance from ... based on current timestamp : When you expect a date to be 3 days in the past, whenever you run the testcase, you would pick the current day - 3 days. The assertion will verify if the actual day is three days before the current execution date. Date is day of run date (today) Date is day before run date (today) Date is day after run date (today) Date applies formatting Floating point value A Floating point is a double or float value. Number is equal ... Number is smaller than ... Number is greater than ... Number is between lower ... and upper ... Number is NOT between lower ... and upper ... Integer value Number is equal ... Number is smaller than ... Number is greater than ... Number is between lower ... and upper ... Number is NOT between lower ... and upper ... Number is in expected list Text Text is a good option, if your uncertain about the return value type, but know, there is no array being returned. Text contains expected Text equals expected Text begins with expected Text ends with expected Text contains expected (case insensitive) Text equals expected (case insensitive) Text begins with expected (case insensitive) Text ends with expected (case insensitive) Text is empty Text is NOT empty Text has expected length Text has minimum expected length Text has maximum expected length Dictionary JSON is constructed from Arrays and Dictionaries, so assessing content of dictionaries is a common check Dictionary entry exists (Dictionary contains key) Dictionary entry NOT exists (Dictionary does not contain key) Dictionary entry has value Dictionary entry has NOT value Element contains expected Dictionary contains expected (case insensitive) Dictionary NOT contains expected Dictionary NOT contains expected (case insensitive) List of values (Arrays) JSONPath may return arrays, APIJockey Test makes it easy to perform validation for all of the entries List of boolean values All elements return true All elements return false List of integer values All values equal expected All values smaller expected All values greater expected All values between lower and upper range All values NOT between lower and upper range number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected number (of array element) count between ... and ... number (of array element) count NOT between ... and ... List of date values All dates are not nil All dates are nil or not present All values are equal expected All values are equal to relative date based on current timestamp : When you expect a date to be 3 days in the past, whenever you run the testcase, you would pick the current day - 3 days. The assertion will verify if the actual day is three days before the current execution date. All dates are today All dates are yesterday All dates are tomorrow All dates apply formatting List of floating values All have expected value All are smaller expected All are greater expected number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected number (of array element) count between ... and ... number (of array element) count NOT between ... and ... All elements between lower and upper range All elements NOT between lower and upper range List of text values All values equal expected expected All values begin with expected All values end with expected All values contain expected All values begin with expected (case insensitive) All values end with expected (case insensitive) All values contain expected (case insensitive) number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected List of dictionaries {#dictionaryarray} All dictionaries have expected key None of the dictionaries have expected key Element count equals expected Element count smaller expected Element count greater expected Element count between ... and ... Element count NOT between ... and ... All dictionaries have expected value None of the dictionaries havs expected value All dictionaries contain expected value None of the dictionaries contain expected value All dictionaries contain expected value (case insensitive) None of the dictionaries contain expected value (case insensitive) Expected value The expected value depends on the assertion test type and is either: single expected value a lower range limit and an upper range limit a list of values A JSON dictionary key name Run assertion Run assesses the current response data against the assertion test type, the expected value and the actual value. The actual JSON response is kept in memory, so you can rerun a test as often as you want and change it. PDF Assertion editor A PDF Assertion verifies, if a text appears in a PDF-File. ![Image assertion editor] (storage/PDFAssertionEditorConfig.png) Query Type As a first step, you need to configure, where the image data should be taken from. There are four options: JSONPath , enter the JSONPath expression to the binary data in the response that represents the PDF. XPath 1 (with function support) , enter the XPath expression to the binary data that represents the PDF. Note: If you work with MTOM, you will need to select the href attribute which holds the content-ID reference.** XQuery / XPath 2 (no function support), enter the XPath expression to the binary data that represents the PDF. Plain Document data, the response is expected to hold binary data that represent the PDF. The blue run button together with the result status (green checkmark) validates the assertion and gives you immediate feedback. Configure your PDF assertion You have several assertion types to verify a PDF document Number of pages where you enter the expected page count. Document contains text on page (number) where you enter the expected text and the page nr. Page (number) has label where you enter the expected text and the page nr. Document is locked where you provide if the flag must be TRUE or FALSE Document is encrypted where you provide if the flag must be TRUE or FALSE Document allows copying where you provide if the flag must be TRUE or FALSE Document allows printing where you provide if the flag must be TRUE or FALSE Document allows commenting where you provide if the flag must be TRUE or FALSE Document allows inserting, deleting or rotating where you provide if the flag must be TRUE or FALSE Document allows changes (expect document attributes) where you provide if the flag must be TRUE or FALSE Document allows form field entries where you provide if the flag must be TRUE or FALSE Search Options When you select assertion types that search for text, you have to search options: case insensitive literal (read character by character) ![PDF assertion options] (storage/PDFAssertionOptions.png) Preview your query When you run the query (blue run button), APIJockey TEST will try to run the query against the response. If this successful, the data will be used to interprete it as base64-encoded PDF data, if you query with JSONPath, XQuery or XPath. I. IF the query is set to Plain document data the response data is interpreted as plain PDF data. If reading the data and interpreting as PDF is successful, the PDF document appears in the tab PDF View , together with the base64-encoded query result in the tab Result , which may help you to fine-tune your query expression. XPath Assertion editor equals with strict text comparison of the response against the expected results contains with simple check if the response contains the expected results count compares the number of elements based on evaluting the assertion against the response with the number in expected results countGreater compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be greater countGreaterEquals compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be equal or greater countSmaller compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be smaller countSmallerEquals compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be smaller or equal notExists verifies that no element is found by the assertion expression against the reponse beginsWith with simple check if the response begins with the expected results endsWith with simple check if the response ends with the expected results Sample assertion with failed run result. Error messages are displayed in place. ![Assertion editor screenshot with error] (storage/assertioneditor-with-error.png) Value providers Datatransfer Teststep Testing efficiently means to link Teststeps efficiently together. A testcase will often use a set data. Often, this come from previous stepsUse a Datatransfer teststep to transfer data from a SOAP or HTTP Teststep to a stored variable. A Datatransfer Teststep may contain a list of datatransfers of different types Examples You must authenticate for a webservice through a security token service and provide a token for the business webservice under test. You receive a list of results and need to select a specific element for further test steps Supported Datatransfer Value Providers XPath Value Providers XQuery Value Providers JSONPath Value Providers Text Value Providers Overview A Datatransfer Teststep can be created in the Teststep List View . Once it is created, selecting a Datatransfer Teststeps displays the following details view Create new XPath Value Provider, opens a dialog where you enter the name of the XPath Value Provider and creates a new list element. Create new XQuery Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Create new JSONPath Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Create new Text Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Rename selected Datatransfer opens a dialog where you can change the name of the Datatransfer Result status of the current run displays an icon that visualizes the last run (success, failed, not started) Run selected Datatransfer(s) will run your configuration and displays the results for each Datatransfer ValueProvider in the selected list Enable/disable selected Datatransfer(s) will mark the ValueProviders to be included/excluded in Test runs Move selected Datatransfer(s) down can help you to better organize your ValueProviders. Move selected Datatransfer(s) up can help you to better organize your ValueProviders. You see the Datatransfer list (ValueProviders), which is empty when you create a new Datatransfer Teststep When you have may ValueProviders you may filter them by name, where we check the entered text to be contained in the ValueProvider name Pasteboard Commands Configuration of ValueProvides When yu want to extract data from SOAP/HTTP Teststep you will create one of the above mentioned ValueProviders. Each ValueProvider has its own functionality to get data from a request or response, but the general approach is as follows You select a supported Teststep e.g. SOAP Teststep for Xpath or HTTP Teststep for JSONPath in the containing Testcase You select if you want to use the request or the response You configure/define you extraction logik (This is specific for each ValueProvider You attach am variable to Value Provider. All ValueProviders use a common view VariableValueTransfer to perform this task A test run is successful, if input teststep is defined, the type (request,responseI is configured, the extraction logic does not run into an error (e.g. wrong Xpath) and a variable is referenced by this ValueProvider XPath Value Provider An XPath Value Provider allows to enter an XPath and run the XPath against a defined request or response. The result is stored in a variable as described above. When you create an XPath Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick a SOAP- or HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response select XPath from existing request/response IF you have a teststep that holds a request or response you can select an element here. When the request/response is empty, the view will not show up enter your xpath allows you to enter an XPath, please make sure, you use XPath 1. When you edit the XPath we read the namespaces from request/response, otherwise you will have to edit it manually in the tab Namespaces Variable Value Transfer configures the referenced variable that will hold the Xpath expression result XQuery Value Provider An XQuery Value Provider allows you to enter a simplified XQuery or XPath expression (which supports unnamed prefixes like *:element) and run the expression against a request or response. The result is stored in a variable as described above. When you create an XQuery Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick a SOAP- or HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response enter your XQuery or XPath , this ValueProvider supports a simplified XQuery/XPath 2 expression. As you can use unnamed prefixes like *:element, there is no support for prefix/namespace mappings. Variable Value Transfer configures the referenced variable that will hold the Xpath expression result JSONPath Value Provider A JSONPath Value Provider allows you to enter a JSONPath expression and run the expression against an HTTP Teststep request or response When you create a JSONPath Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick an HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response enter your jsonpath that will select the elements from your request/response Variable Value Transfer configures the referenced variable that will hold the Xpath expression result Text Value Provider A Text Value Provider allows you to arrange a list of Text transformations in an ordered list to retrieve and transform text To illustrate how it works, we added a screenshot with a ready-configured Text Value Provider that reads a JSON-response AND has linked a variable that holds the result The operations are applied in the order in which they are defined in the list and can be enabled/disabled, moved up and moved down You can include the following operations: select substring with providing start and end index startIndex 0 with endIndex 0 selects the first character startIndex -1 with endIndex -1 selects the whole text search and replace with providing the static search and static replacing text encode to base64 creates the base64 representation of the text decode from base64 recreates the original text from the base representation, which is disabled in this example Variable Value Transfer configures the referenced variable that will hold the Xpath expression result, which is done here for a variable on the Testcase","title":"Configuration views and editors"},{"location":"teststepconfigviews/#application-overview","text":"When you open APIJockey TEST you will see this layout:","title":"Application Overview"},{"location":"teststepconfigviews/#view-variables","text":"The Variables view consists actually of four views that allow to manage variables on different test definition elements. Repository Testset Testcase Teststep The status of the variables views and their visibility depends - of course - of your current selection.","title":"View Variables"},{"location":"teststepconfigviews/#base-variable-view","text":"The Variable views have all the same structure they just differ in the variable type and their parent type. The Variables parent selector tabs depend on your current selection. In the above screenshot, there are four tabs visible (repository, testset, testcase and teststep). You can deselect a repostory without losing the selection of the underlying testset. The name below the variables parent selector tabs is the name of parent element you have selected with your tabs, in this case the teststep Enumerate , as you can see on the right.","title":"Base Variable View"},{"location":"teststepconfigviews/#commands","text":"Show/hide variables toggles the variables list. This may be helpful to have more space when editing testsets and repositories Export all variables will prompt for a directory and creates a properties file (key/value, separated by = ) for all visible variable parents Import variables will prompt for a properties file (see above) contents and read the values as String variables Export variables will prompt for file name and location and creates a properties file (see above) Create new variable opens the variables editor as described above Delete selected variables deletes these variables. Edit a selected variable allows you to change the variable type, the name and the value Documentation of the Pasteboard commands","title":"Commands"},{"location":"teststepconfigviews/#variables-editor","text":"As described in Concepts , variables represent various value types and can be formatted in many ways. This paragraph walks through the variable editor options","title":"Variables editor"},{"location":"teststepconfigviews/#variable-types","text":"","title":"Variable types"},{"location":"teststepconfigviews/#string-variables","text":"Enter arbitrary-length Text. No formatting occurs.","title":"String Variables"},{"location":"teststepconfigviews/#password-variables-editor","text":"Enter arbitrary-length Text. No formatting occurs. The variable list will not show the variable value. The varaible value will not be shown with the toggle on off (storage/Variables-Editor-passwordvalue-undisclosed.png) ![Variables editor password value undisclosed] To see the actual password value, set the toggle to on (storage/Variables-Editor-passwordvalue-disclosed.png) ![Variables editor password value disclosed]","title":"Password Variables Editor"},{"location":"teststepconfigviews/#fixed-date-variables-editor","text":"The fixed/static date variables editor uses the builtin date picker to select a date and a time. The editor defaults the formatting to yyyy-mm-dd, but you can apply any supported formatting like yyyy-mm-dd'T'HH:mm:ss","title":"Fixed Date Variables Editor"},{"location":"teststepconfigviews/#relative-date-variables-editor","text":"The relative date variables editor uses the builtin date/time picker to select a date, and if required a time. The editor defaults the formatting to yyyy-mm-dd, but you can apply any supported formatting like yyyy-mm-dd'T'HH:mm:ss. The reevaluation occurs whenever the variables value is accessed, so even in the variables list, this value is reevaluted when the list view updates.","title":"Relative Date Variables Editor"},{"location":"teststepconfigviews/#number-variables-editor","text":"Number formatting is another frequent requirement as SOAP Webservices expect an identifiable number formatting and schema are pretty strict with the provided formatting. In general they expect simple numbers though.","title":"Number Variables Editor"},{"location":"teststepconfigviews/#boolean-variables-editor","text":"The Editor supports two options true/false yes/no","title":"Boolean Variables Editor"},{"location":"teststepconfigviews/#run-environment-variables","text":"As described in [View Run Environment]{#viewrunenvironment} you can configure authentication for a Webservice in a Run Environment Configuration. Data that is configured here, will be accessed, when the user selects the corresponding Run Environment. When you want to access these information within your request, you can provide these values through Run Environment Variables, as described here: Authentication type Textfield name Variable notation in Test definition HTTP basic Authentication HTTP username $(EnvironmentConfig.httpUsername) HTTP basic Authentication HTTP password $(EnvironmentConfig.httpPassword) HTTP bearer Authentication HTTP bearer token $(EnvironmentConfig.bearerToken) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadUsername) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadPassword) None (No HTTP authentication) Payload OTP $(EnvironmentConfig.payloadOTP) None (No HTTP authentication) Payload Token $(EnvironmentConfig.payloadToken) We want to illustrate this specific variable resolution mechanism with the example of a sample request that needs to provide a username, a password, an OTP (fixed) in the Test Run Environment and a Token variable, that is retrieved from another request ) We configure a Service Definition for the local Run Environment with NONE-Authentication which means we will use an Idenity Service and pass over data. The relevant input is highlighted in blue, you will notice the variable value for the payloadToken information. We will pass the four information in an HTTP request (which could be a SOAP request as well. We have set the Run Environment to localhost . Notice the Repository variable with name token .Our request looks like this: Now, we switch to the tab resolvedRequest to see what the variables are resolve to:","title":"Run environment Variables"},{"location":"teststepconfigviews/#variablevaluetransfer","text":"A VariableValueTransfer designates a value (random value, manual or CSV-file input XPATH-expression JSONPath-expression) to a variable. It also server to write Variable values to a result table. When you want to use dynamic data in your requests, you will always access variable. The origin of the variable data is abstracted in the access and the VariablesValueTransfer describes this data transfer.","title":"VariableValueTransfer"},{"location":"teststepconfigviews/#configure-a-variablevaluetransfer","text":"When you work with any of these teststeps, you will have to handle the included VariableValueTransfer: View RandomizeTeststep View RandomizedvaluelistTeststep View Manual RandomizedvaluelistTeststep View DatatransferTeststep Conceptual overview of Databased Testcases A variable can be referenced, if it is defined within the teststeps' Test definition Hierarchy on the teststep on the teststep's parent testcase on the teststeps's parent testset on the teststeps's parent repository When you create a new value provider, the variable's parent type is defaulted to testcase . If you want to change this, click with your mouse on the button remove configuration . We will keep the setting as defaulted. Click with your mouse on the button Add Variable . This will open a dialog. Enter the name vin and keep the value as it is. If you switch the tab to something else than String (variable type), this entry will not be visible. Cconfirm with OK You will see a new entry. Click with your mouse on this list entry. Now, the variable is reference, you shoud see the following view. The random value provider is fully configured. You can run your value provider, now. Click with your mouse the on the button test run value provider . the updated value appears in the reference the reference variable view The random value in the screenshot will probably be different from the one you see.. You can reference your variable in the requesteditor as: $(Testcase.vin)","title":"Configure a VariableValueTransfer"},{"location":"teststepconfigviews/#view-run-environment","text":"this view can be found in the Viewgroup Environment The conceptual overview of working with different environments can be found in Run Environment Find a detailed description of the Run Environment View here","title":"View Run Environment"},{"location":"teststepconfigviews/#list-of-run-environments","text":"list of environments displays all environments. Environments allow a service related configuration for URLs and authentication information new Environment creates a new entry delete removes an environment rename lets you change the list display name, which also affects the Run Environment picker text in the Viewgroup Testdefinition move up the position of the selected entries move down the position of the selected entries copy an existing entry to create a new entry","title":"List of Run Environments"},{"location":"teststepconfigviews/#run-environment-configurations-for-a-service-definition","text":"When you select en entry you can configure Run Environment specific settings, either empty ![screenshot Run Environment with empty Service Configuration] (storage/RunEnvironmentEmptyConfiguration.png) Add will create a new configuration for the selected Run Environment time travel on the Service Definition My HTTP Service two When you click Add you will see a configuration dialog, outlined with screenshot for an existing configuration on another Service Definition: (storage/RunEnvironmentServiceDefinition.png) ![screenshot Run Environment Service Definition] This is a screenshot from a Manual HTTP Service Definition Run Environment configuration for an environment time travel . The SOAP definition differs only in the URL input, which is described below.","title":"Run Environment configurations for a Service Definition"},{"location":"teststepconfigviews/#settings-for-run-environment-service-definitions","text":"On the top, you see the currently seelcted run environment name You enter the host url and the port for a Manual HTTP Service Definition or a complete URL for SOAP Service. We expect non-SOAP Service to use routes and query parameters added to the host url that will not differ between environments but teststep specific, where soap service have just different URLs without route and query parameters Authentication has three options: Basic HTTP Authentication, you provide a username and a password which will be used to create the HTTP Header Authorization Basic . See the example configuration in the screenshot above Bearer HTTP Authentication, you provide a token information which will be used to create a HTTP Header Authorization Bearer NO HTTP Authentication, you may provide a payload username a payload password , a payload OTP ** and/or a payload token** that may be static or be variable","title":"Settings for Run Environment Service Definitions"},{"location":"teststepconfigviews/#resolution-process-for-run-environment-settings","text":"See Run Environment for the conceptual overview. In the case of basic and bearer authentication, APIJockey Test handles adding the Headers for you. It will resolve the information entered in this configuration screenshot. You can access the authentication information in your payload by using variables, in the case you need to authentication against an Identity Service to get authorized for a business service You can use variables in the configuration, if you need to run an authentication call and want to store a token in a repository variable. For convenience, find all EnvironmentConfig Variables here with the notation to use in your Test Definition Authentication type Textfield name Variable notation in Test definition HTTP basic Authentication HTTP username $(EnvironmentConfig.httpUsername) HTTP basic Authentication HTTP password $(EnvironmentConfig.httpPassword) HTTP bearer Authentication HTTP bearer token $(EnvironmentConfig.bearerToken) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadUsername) None (No HTTP authentication) Payload username $(EnvironmentConfig.payloadPassword) None (No HTTP authentication) Payload OTP $(EnvironmentConfig.payloadOTP) None (No HTTP authentication) Payload Token $(EnvironmentConfig.payloadToken)","title":"Resolution process for Run Environment settings"},{"location":"teststepconfigviews/#soap-attachments","text":"The SOAP Request editor provides a tab Attachments to edit, update and delete attachments","title":"SOAP Attachments"},{"location":"teststepconfigviews/#command-overview","text":"Create new attachment adds a new enty in the attachments list. You need to load the actual content later, as in the screenshot. Delete removes the selected attachments from the attachments list. The local file disc content is not removed. Rename lets you change the name of the selected attachment. The attachment name is not used in the request and helps you organize your attachment list. Move Up changes the order of the selected attachment entries. This has not impact on the request Move Down changes the order of the selected attachment entries. This has not impact on the request Load from disc opens a file open dialog where you can select the file to attach. Select and confirm will load the file contents and insert them to the attachment entry, It will try to recognizes the appropriate MIME type. Edit MIME type lets you set your own MIME type that is uses in the request","title":"Command overview"},{"location":"teststepconfigviews/#create-a-new-attachment","text":"Click with your mouse on the button Create new attachment . This will open a new dialog. ![Dialog new SOAPRequestAttachment] (storage/Dialogs-NewSOAPRequestAttachment.png) Enter the name (e.g. invoice) and confirm with OK. This will create a new attachment as in the screenshot above. Click with your mouse on the button Load from disc to insert the local file contents. In the screenshot this is an invoice that should be sent with request to test an upload functionality. The content is - if supported - in the content preview","title":"Create a new attachment"},{"location":"teststepconfigviews/#supported-type","text":"s The builtin attachments preview supports: PDF-Documents Images Text If the content type is different, no preview is shown, the attachment will still be sent with the request.","title":"Supported Type"},{"location":"teststepconfigviews/#reference-attachments","text":"If you want to reference the attachment in the request editor, click with your mouse on the button Copy to Pasteboard . The Pasteboard will contain a string like so: $(Attachment.CID:8FD11DF7-5DE5-49FD-A6A8-D1C7B1DB6A83@apijockey.com). You can copy this text in any element like in the screenshot for the element msg:Data","title":"Reference attachments"},{"location":"teststepconfigviews/#assertion-editors","text":"","title":"Assertion editors"},{"location":"teststepconfigviews/#http-assertion-editor","text":"An HTTP assertion verifies basic HTTP-URL request specific information. HTTP Assertions are available for both HTTP Teststep and SOAP Teststep .","title":"HTTP assertion editor"},{"location":"teststepconfigviews/#assertion-value","text":"Currently, there are three different data, that can be assessed: Status (HTTP Status) Data length (Binary data length) Response time (measured in ms)","title":"Assertion value"},{"location":"teststepconfigviews/#assertion-test-type","text":"The assertion test type depends on the value type being assessed. For HTTP assertions these are integer values, so the assertion test type provides a set of options that make sense for integers. is equal to (single expected value) is smaller than (single expected value) is greater than (single expected value) is between ... and ... is not between ... and ... is in List","title":"Assertion test type"},{"location":"teststepconfigviews/#expected-value","text":"The expected value depends on the assertion test type and is either: single expected value a lower range limit and an upper range limit a list of values","title":"Expected value"},{"location":"teststepconfigviews/#run-assertion","text":"Run assesses the current response data against the assertion test type, the expected value and the actual value. The actual HTTP values are kept in memory, so you can rerun a test as often as you want and change it.","title":"Run assertion"},{"location":"teststepconfigviews/#image-assertion-editor","text":"An Image assertion uses a trained machine learning model to capture the text contents of a file.","title":"Image Assertion editor"},{"location":"teststepconfigviews/#query-type","text":"As a first step, you need to configure, where the image data should be taken from. There are four options: JSONPath , enter the JSONPath expression to the binary data in the response that represents the image. XPath 1 (with function support) , enter the XPath expression to the binary data that represents the image. Note: If you work with MTOM, you will need to select the href attribute which holds the content-ID reference.** XQuery / XPath 2 (no function support), enter the XPath expression to the binary data that represents the image. Plain Document data, the response is expected to hold binary data that represent the image.","title":"Query Type"},{"location":"teststepconfigviews/#configure-your-image-assertion","text":"You have three options to check Text content on an image Contains text enter the expected text. Contains text (ignore case), enter the expected text. Barcode , enter the expected payload The blue run button together with the result status (green checkmark) validates the assertion and gives you immediate feedback.","title":"Configure your Image assertion"},{"location":"teststepconfigviews/#preview","text":"When you run the query (blue run button), APIJockey TEST will try to read the Image data, supported types are TIFF, PNG, JPEG, GIF and PDF. IF this is successful you will see the received image in the preview, together with the assertion run results as in the screenshot below:","title":"Preview"},{"location":"teststepconfigviews/#query-result","text":"It seems odd that both preview and response view show the same content. This is the case as the response contains the image only. In other cases you might have a JSON Response or a SOAP Response and would apply JSONPath, XQuery or XPath to extract the Base64 encoded data, which would then internally be transformed to binary image data. If this is the case, you will see another tab Query Result that should help you identify, what part of the response document is returned by your query.","title":"Query result"},{"location":"teststepconfigviews/#textbarcode-identification","text":"When the assertion run is completed you will see a tab Text identification or Barcode identification depending on your Assertion type. This tab holds a list of Texts / Barcode payload found during the AI-scan together with a confidence vote. This can help you decide, if you want to run the assertion automatically or manually only, as a low confidence vote might be an indicator for a hit that is on reliably reproduceable. Also keep in mind that ML-model are non-deterministic. In our sample, the text identification gives these results:","title":"Text/Barcode identification"},{"location":"teststepconfigviews/#json-assertion-editor","text":"The JSON assertion editor allows you to configure and run assertions against JSON response data with JSONPath. JSONPath can return a single (complex) value or a list of values.","title":"JSON assertion editor"},{"location":"teststepconfigviews/#jsonpath-editor-with-expression","text":"Writing assertions can be cumbersome if you need to work with several query languages, like SQL, JSONPath and XPath to mention some of them. APIJockey TEST supports you with a large set of predefined queries that can apply on your JSON objects. The idea is to let you query the JSON objects with a small subset of JSONPath expressions and assert these objects in various ways by configuring what you actually want to test. A JSON assertion expects a valid JSONPath expression. You may enter you assertion here. The JSONPath assertion will be executed against the current response. In case of errors, these will be displayed in the editor.","title":"JSONPath editor with expression"},{"location":"teststepconfigviews/#expected-return-type","text":"When you edit a JSONPath Expression, you need to select the type of return value that you expect. We will use this information to provide an appropriate set of assertion test types: The JSON assertion in the above screenshot selects a list of prices. Thus, the expected return type is set to list of floating values. You have the following list of expected return types:","title":"Expected return type"},{"location":"teststepconfigviews/#return-types-that-expect-one-value","text":"The assertion will fail, if the expected return type does not equal the actual return type, e.g. expected: List of booleans, actual: single boolean. The assertion type determines the way the assertion is verified:","title":"Return types that expect one value"},{"location":"teststepconfigviews/#boolean-value","text":"true false","title":"Boolean value"},{"location":"teststepconfigviews/#date-with-formatting","text":"Date is day of run date Date is not nil Date is nil/null or not present Date is equal expected day Date has equal distance from ... based on current timestamp : When you expect a date to be 3 days in the past, whenever you run the testcase, you would pick the current day - 3 days. The assertion will verify if the actual day is three days before the current execution date. Date is day of run date (today) Date is day before run date (today) Date is day after run date (today) Date applies formatting","title":"Date with formatting"},{"location":"teststepconfigviews/#floating-point-value","text":"A Floating point is a double or float value. Number is equal ... Number is smaller than ... Number is greater than ... Number is between lower ... and upper ... Number is NOT between lower ... and upper ...","title":"Floating point value"},{"location":"teststepconfigviews/#integer-value","text":"Number is equal ... Number is smaller than ... Number is greater than ... Number is between lower ... and upper ... Number is NOT between lower ... and upper ... Number is in expected list","title":"Integer value"},{"location":"teststepconfigviews/#text","text":"Text is a good option, if your uncertain about the return value type, but know, there is no array being returned. Text contains expected Text equals expected Text begins with expected Text ends with expected Text contains expected (case insensitive) Text equals expected (case insensitive) Text begins with expected (case insensitive) Text ends with expected (case insensitive) Text is empty Text is NOT empty Text has expected length Text has minimum expected length Text has maximum expected length","title":"Text"},{"location":"teststepconfigviews/#dictionary","text":"JSON is constructed from Arrays and Dictionaries, so assessing content of dictionaries is a common check Dictionary entry exists (Dictionary contains key) Dictionary entry NOT exists (Dictionary does not contain key) Dictionary entry has value Dictionary entry has NOT value Element contains expected Dictionary contains expected (case insensitive) Dictionary NOT contains expected Dictionary NOT contains expected (case insensitive)","title":"Dictionary"},{"location":"teststepconfigviews/#list-of-values-arrays","text":"JSONPath may return arrays, APIJockey Test makes it easy to perform validation for all of the entries","title":"List of values (Arrays)"},{"location":"teststepconfigviews/#list-of-boolean-values","text":"All elements return true All elements return false","title":"List of boolean values"},{"location":"teststepconfigviews/#list-of-integer-values","text":"All values equal expected All values smaller expected All values greater expected All values between lower and upper range All values NOT between lower and upper range number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected number (of array element) count between ... and ... number (of array element) count NOT between ... and ...","title":"List of integer values"},{"location":"teststepconfigviews/#list-of-date-values","text":"All dates are not nil All dates are nil or not present All values are equal expected All values are equal to relative date based on current timestamp : When you expect a date to be 3 days in the past, whenever you run the testcase, you would pick the current day - 3 days. The assertion will verify if the actual day is three days before the current execution date. All dates are today All dates are yesterday All dates are tomorrow All dates apply formatting","title":"List of date values"},{"location":"teststepconfigviews/#list-of-floating-values","text":"All have expected value All are smaller expected All are greater expected number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected number (of array element) count between ... and ... number (of array element) count NOT between ... and ... All elements between lower and upper range All elements NOT between lower and upper range","title":"List of floating values"},{"location":"teststepconfigviews/#list-of-text-values","text":"All values equal expected expected All values begin with expected All values end with expected All values contain expected All values begin with expected (case insensitive) All values end with expected (case insensitive) All values contain expected (case insensitive) number (of array element) count equals expected number (of array element) count smaller expected number (of array element) count greater expected","title":"List of text values"},{"location":"teststepconfigviews/#list-of-dictionaries-dictionaryarray","text":"All dictionaries have expected key None of the dictionaries have expected key Element count equals expected Element count smaller expected Element count greater expected Element count between ... and ... Element count NOT between ... and ... All dictionaries have expected value None of the dictionaries havs expected value All dictionaries contain expected value None of the dictionaries contain expected value All dictionaries contain expected value (case insensitive) None of the dictionaries contain expected value (case insensitive)","title":"List of dictionaries {#dictionaryarray}"},{"location":"teststepconfigviews/#expected-value_1","text":"The expected value depends on the assertion test type and is either: single expected value a lower range limit and an upper range limit a list of values A JSON dictionary key name","title":"Expected value"},{"location":"teststepconfigviews/#run-assertion_1","text":"Run assesses the current response data against the assertion test type, the expected value and the actual value. The actual JSON response is kept in memory, so you can rerun a test as often as you want and change it.","title":"Run assertion"},{"location":"teststepconfigviews/#pdf-assertion-editor","text":"A PDF Assertion verifies, if a text appears in a PDF-File. ![Image assertion editor] (storage/PDFAssertionEditorConfig.png)","title":"PDF Assertion editor"},{"location":"teststepconfigviews/#query-type_1","text":"As a first step, you need to configure, where the image data should be taken from. There are four options: JSONPath , enter the JSONPath expression to the binary data in the response that represents the PDF. XPath 1 (with function support) , enter the XPath expression to the binary data that represents the PDF. Note: If you work with MTOM, you will need to select the href attribute which holds the content-ID reference.** XQuery / XPath 2 (no function support), enter the XPath expression to the binary data that represents the PDF. Plain Document data, the response is expected to hold binary data that represent the PDF. The blue run button together with the result status (green checkmark) validates the assertion and gives you immediate feedback.","title":"Query Type"},{"location":"teststepconfigviews/#configure-your-pdf-assertion","text":"You have several assertion types to verify a PDF document Number of pages where you enter the expected page count. Document contains text on page (number) where you enter the expected text and the page nr. Page (number) has label where you enter the expected text and the page nr. Document is locked where you provide if the flag must be TRUE or FALSE Document is encrypted where you provide if the flag must be TRUE or FALSE Document allows copying where you provide if the flag must be TRUE or FALSE Document allows printing where you provide if the flag must be TRUE or FALSE Document allows commenting where you provide if the flag must be TRUE or FALSE Document allows inserting, deleting or rotating where you provide if the flag must be TRUE or FALSE Document allows changes (expect document attributes) where you provide if the flag must be TRUE or FALSE Document allows form field entries where you provide if the flag must be TRUE or FALSE","title":"Configure your PDF assertion"},{"location":"teststepconfigviews/#search-options","text":"When you select assertion types that search for text, you have to search options: case insensitive literal (read character by character) ![PDF assertion options] (storage/PDFAssertionOptions.png)","title":"Search Options"},{"location":"teststepconfigviews/#preview-your-query","text":"When you run the query (blue run button), APIJockey TEST will try to run the query against the response. If this successful, the data will be used to interprete it as base64-encoded PDF data, if you query with JSONPath, XQuery or XPath. I. IF the query is set to Plain document data the response data is interpreted as plain PDF data. If reading the data and interpreting as PDF is successful, the PDF document appears in the tab PDF View , together with the base64-encoded query result in the tab Result , which may help you to fine-tune your query expression.","title":"Preview your query"},{"location":"teststepconfigviews/#xpath-assertion-editor","text":"equals with strict text comparison of the response against the expected results contains with simple check if the response contains the expected results count compares the number of elements based on evaluting the assertion against the response with the number in expected results countGreater compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be greater countGreaterEquals compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be equal or greater countSmaller compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be smaller countSmallerEquals compares the number of elements based on evaluting the assertion against the response with the number in expected results , which must be smaller or equal notExists verifies that no element is found by the assertion expression against the reponse beginsWith with simple check if the response begins with the expected results endsWith with simple check if the response ends with the expected results Sample assertion with failed run result. Error messages are displayed in place. ![Assertion editor screenshot with error] (storage/assertioneditor-with-error.png)","title":"XPath Assertion editor"},{"location":"teststepconfigviews/#value-providers","text":"","title":"Value providers"},{"location":"teststepconfigviews/#datatransfer-teststep","text":"Testing efficiently means to link Teststeps efficiently together. A testcase will often use a set data. Often, this come from previous stepsUse a Datatransfer teststep to transfer data from a SOAP or HTTP Teststep to a stored variable. A Datatransfer Teststep may contain a list of datatransfers of different types Examples You must authenticate for a webservice through a security token service and provide a token for the business webservice under test. You receive a list of results and need to select a specific element for further test steps","title":"Datatransfer Teststep"},{"location":"teststepconfigviews/#supported-datatransfer-value-providers","text":"XPath Value Providers XQuery Value Providers JSONPath Value Providers Text Value Providers","title":"Supported Datatransfer Value Providers"},{"location":"teststepconfigviews/#overview","text":"A Datatransfer Teststep can be created in the Teststep List View . Once it is created, selecting a Datatransfer Teststeps displays the following details view Create new XPath Value Provider, opens a dialog where you enter the name of the XPath Value Provider and creates a new list element. Create new XQuery Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Create new JSONPath Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Create new Text Value Provider, opens a dialog where you enter the name of the XQuery Value Provider and creates a new list element. Rename selected Datatransfer opens a dialog where you can change the name of the Datatransfer Result status of the current run displays an icon that visualizes the last run (success, failed, not started) Run selected Datatransfer(s) will run your configuration and displays the results for each Datatransfer ValueProvider in the selected list Enable/disable selected Datatransfer(s) will mark the ValueProviders to be included/excluded in Test runs Move selected Datatransfer(s) down can help you to better organize your ValueProviders. Move selected Datatransfer(s) up can help you to better organize your ValueProviders. You see the Datatransfer list (ValueProviders), which is empty when you create a new Datatransfer Teststep When you have may ValueProviders you may filter them by name, where we check the entered text to be contained in the ValueProvider name Pasteboard Commands","title":"Overview"},{"location":"teststepconfigviews/#configuration-of-valueprovides","text":"When yu want to extract data from SOAP/HTTP Teststep you will create one of the above mentioned ValueProviders. Each ValueProvider has its own functionality to get data from a request or response, but the general approach is as follows You select a supported Teststep e.g. SOAP Teststep for Xpath or HTTP Teststep for JSONPath in the containing Testcase You select if you want to use the request or the response You configure/define you extraction logik (This is specific for each ValueProvider You attach am variable to Value Provider. All ValueProviders use a common view VariableValueTransfer to perform this task A test run is successful, if input teststep is defined, the type (request,responseI is configured, the extraction logic does not run into an error (e.g. wrong Xpath) and a variable is referenced by this ValueProvider","title":"Configuration of ValueProvides"},{"location":"teststepconfigviews/#xpath-value-provider","text":"An XPath Value Provider allows to enter an XPath and run the XPath against a defined request or response. The result is stored in a variable as described above. When you create an XPath Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick a SOAP- or HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response select XPath from existing request/response IF you have a teststep that holds a request or response you can select an element here. When the request/response is empty, the view will not show up enter your xpath allows you to enter an XPath, please make sure, you use XPath 1. When you edit the XPath we read the namespaces from request/response, otherwise you will have to edit it manually in the tab Namespaces Variable Value Transfer configures the referenced variable that will hold the Xpath expression result","title":"XPath Value Provider"},{"location":"teststepconfigviews/#xquery-value-provider","text":"An XQuery Value Provider allows you to enter a simplified XQuery or XPath expression (which supports unnamed prefixes like *:element) and run the expression against a request or response. The result is stored in a variable as described above. When you create an XQuery Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick a SOAP- or HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response enter your XQuery or XPath , this ValueProvider supports a simplified XQuery/XPath 2 expression. As you can use unnamed prefixes like *:element, there is no support for prefix/namespace mappings. Variable Value Transfer configures the referenced variable that will hold the Xpath expression result","title":"XQuery Value Provider"},{"location":"teststepconfigviews/#jsonpath-value-provider","text":"A JSONPath Value Provider allows you to enter a JSONPath expression and run the expression against an HTTP Teststep request or response When you create a JSONPath Value Provider and select it from the list, you get the following Details view: select input teststep is the first step where you pick an HTTP- Teststep that will hold a request/response When you have selected a teststep you can configure, if you want to read the request or response enter your jsonpath that will select the elements from your request/response Variable Value Transfer configures the referenced variable that will hold the Xpath expression result","title":"JSONPath Value Provider"},{"location":"teststepconfigviews/#text-value-provider","text":"A Text Value Provider allows you to arrange a list of Text transformations in an ordered list to retrieve and transform text To illustrate how it works, we added a screenshot with a ready-configured Text Value Provider that reads a JSON-response AND has linked a variable that holds the result The operations are applied in the order in which they are defined in the list and can be enabled/disabled, moved up and moved down You can include the following operations: select substring with providing start and end index startIndex 0 with endIndex 0 selects the first character startIndex -1 with endIndex -1 selects the whole text search and replace with providing the static search and static replacing text encode to base64 creates the base64 representation of the text decode from base64 recreates the original text from the base representation, which is disabled in this example Variable Value Transfer configures the referenced variable that will hold the Xpath expression result, which is done here for a variable on the Testcase","title":"Text Value Provider"},{"location":"views-repositories-testsets/","text":"Testdefinition hierarchy You manage and maintain your test definition hierarchy in four views, where two of them are located inthe sidebar: The sidebar includes two followinglist view: Repository list view Testset list view The sidebar appearance can be changed with the following toggles Show/hide sidebar Show Testsets on: will show the Testsets List View , off: will not display them. Repository list view A repository is an organizational bucket where you can enter your testsets and testcases. All your definitions are synchronized on your iCloud storage across your MacOS-devices. This view displays all repositories and provides commands to create, edit, delete and test run commands. This view is intended to edit in the repository list or run a repository-based test and view the unterlying testsets at the same time. You Commands illustrated on the left side from top to down without the view toggle commented in the previous section We follow the icons from left to right and list the views from top to down. Create new repository adds a new repository enable/disable repository for test run includes or excludes a repository for test run or execution run Delete all selected repositories performs the deletion Edit repository name allows to rename a single selected repository move repository up and move repository down has impact on the list order and on the order they are invoked for test runs and execution runs instant run tests in repository starts a test run that walks through alls testsets and their testcase in the order they are displayed in the list views. run test execution for repository starts a test run whose results are persisted and visible. See Test run .This starts a background test run that walks through alls testsets and their testcase in the order they are displayed in the list views. instant test run status for repository and instant test run status for testset show the instant test run status . The test results are not persisted. Search input field filters the repositories based on the input - input must be contained, case insensitive selected repository defines the root element for the Testset List View Documentation of the Pasteboard commands Testset list view The Testset list view is only visible, if the toggle Show testsets is activated Repositories contain Testsets. They are represented in the view above with a folder icon. All command that you can perform on testsets are available through a context menu. Create new Testset will open a dialog to create a new Testset Delete all selected X testset(s) will prompt you to perform the undoable deletion. Rename selected Testset will open a dialog to enter the new name. export selected Testsets to JSON-file will create a JSON-representation of the Testset list with all underlying data. See Import and Export your Test definitions . import Testsets from JSON-file will create new Testsets from a JSON-representation with all underlying data. see Import and Export your Test definitions Toggle enabled/disabled for test run includes or excludes a Testset for a test run. Instantly run Testsets starts a test run that walks through the testcases of the selected testset in the order they are displayed in the list views. The results are not persisted. instant test run status for repository and instant test run status for testset show the instant test run status . The test results are not persisted. move selected Testset(s) up will change the order in th Testset list. move selected Testset(s) down will change the order in th Testset list. Documentation of the Pasteboard commands Testcase list view This view displays the testcases of the selected testset A testcase includes a number of tetsteps to test a specific functionality. Commands Name of parent repository displays the current repository selection Name of parent testset displays the current testset selection create new data-based testcase sets up a base testcase with an input data teststep and a result teststep create new testcase delete all selected testcases Documentation of the Pasteboard commands Special considerations Each testcase is displayed with an icon leading its name . An icon with a dark fill color indicates a testcase with teststeps included, an icon without fill color indicates an empty testcase - move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to help you organize your testcases. enable/disable includes or excludes a testcase on a test run run test starts a test run that walks through all selected testcases in the displayed order, or all testcases, when no testcase is selected. testcase list testrun result status displays the aggregrated test run result status of all executed testcases. testcase testrun result status displays the test run result status of an individual testcase. import testcases from JSON loads testcase information from a JSON file export selected testcases as JSON creates a JSON representation of the selected testcases and stores them to a file rename selected testcase Teststep list view This view displays the teststeps of the selected testcase A teststep performs - depending on the teststep type a type-specific task within a testcase. Commands Create SOAP Teststep opens a dialog to specify the WSDL and the operation that you want to test. See tutorial Create SOAP Teststep Create HTTP Teststep creates a teststep for HTTP requests including JSON body. See tutorial Create HTTP Teststep Create Datatransfer Teststep creates a teststep with an empty list of Teststep value providers such as XPath and XQuery value providers. See Datatransfer Teststep Create RandomizeTeststep creates a teststep with an empty list of random value providers based on concatenated strings or uuids. See View Randomizeteststep Create Randomized ValuelistTeststep creates a teststep that reads a CSV file and allows to configure output columns and their formatting. See Randomizedvaluelist Teststep View . Create Manual Randomized ValuelistTeststep creates a teststep that let you edit a table and allows to configure output columns and their formatting. see Manual RandomizedvaluelistTeststep View . Each Teststep type is displayed with its name and a specific icon to distinguish the teststep type. delete all selected teststeps rename selected teststep move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to define which teststep needs the input of another teststep. enable/disable includes or excludes a teststep on a test run run test starts a test run that walks through all selected teststep in the displayed order, or all teststeps, when no teststep is selected. teststep list testrun result status displays the aggregrated test run result status of all executed teststeps. teststep testrun result status displays the test run result status of an individual teststep. Documentation of the Pasteboard commands","title":"Test hierarchy views"},{"location":"views-repositories-testsets/#testdefinition-hierarchy","text":"You manage and maintain your test definition hierarchy in four views, where two of them are located inthe sidebar: The sidebar includes two followinglist view: Repository list view Testset list view The sidebar appearance can be changed with the following toggles Show/hide sidebar Show Testsets on: will show the Testsets List View , off: will not display them.","title":"Testdefinition hierarchy"},{"location":"views-repositories-testsets/#repository-list-view","text":"A repository is an organizational bucket where you can enter your testsets and testcases. All your definitions are synchronized on your iCloud storage across your MacOS-devices. This view displays all repositories and provides commands to create, edit, delete and test run commands. This view is intended to edit in the repository list or run a repository-based test and view the unterlying testsets at the same time. You Commands illustrated on the left side from top to down without the view toggle commented in the previous section We follow the icons from left to right and list the views from top to down. Create new repository adds a new repository enable/disable repository for test run includes or excludes a repository for test run or execution run Delete all selected repositories performs the deletion Edit repository name allows to rename a single selected repository move repository up and move repository down has impact on the list order and on the order they are invoked for test runs and execution runs instant run tests in repository starts a test run that walks through alls testsets and their testcase in the order they are displayed in the list views. run test execution for repository starts a test run whose results are persisted and visible. See Test run .This starts a background test run that walks through alls testsets and their testcase in the order they are displayed in the list views. instant test run status for repository and instant test run status for testset show the instant test run status . The test results are not persisted. Search input field filters the repositories based on the input - input must be contained, case insensitive selected repository defines the root element for the Testset List View Documentation of the Pasteboard commands","title":"Repository list view"},{"location":"views-repositories-testsets/#testset-list-view","text":"The Testset list view is only visible, if the toggle Show testsets is activated Repositories contain Testsets. They are represented in the view above with a folder icon. All command that you can perform on testsets are available through a context menu. Create new Testset will open a dialog to create a new Testset Delete all selected X testset(s) will prompt you to perform the undoable deletion. Rename selected Testset will open a dialog to enter the new name. export selected Testsets to JSON-file will create a JSON-representation of the Testset list with all underlying data. See Import and Export your Test definitions . import Testsets from JSON-file will create new Testsets from a JSON-representation with all underlying data. see Import and Export your Test definitions Toggle enabled/disabled for test run includes or excludes a Testset for a test run. Instantly run Testsets starts a test run that walks through the testcases of the selected testset in the order they are displayed in the list views. The results are not persisted. instant test run status for repository and instant test run status for testset show the instant test run status . The test results are not persisted. move selected Testset(s) up will change the order in th Testset list. move selected Testset(s) down will change the order in th Testset list. Documentation of the Pasteboard commands","title":"Testset list view"},{"location":"views-repositories-testsets/#testcase-list-view","text":"This view displays the testcases of the selected testset A testcase includes a number of tetsteps to test a specific functionality.","title":"Testcase list view"},{"location":"views-repositories-testsets/#commands","text":"Name of parent repository displays the current repository selection Name of parent testset displays the current testset selection create new data-based testcase sets up a base testcase with an input data teststep and a result teststep create new testcase delete all selected testcases Documentation of the Pasteboard commands","title":"Commands"},{"location":"views-repositories-testsets/#special-considerations","text":"Each testcase is displayed with an icon leading its name . An icon with a dark fill color indicates a testcase with teststeps included, an icon without fill color indicates an empty testcase - move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to help you organize your testcases. enable/disable includes or excludes a testcase on a test run run test starts a test run that walks through all selected testcases in the displayed order, or all testcases, when no testcase is selected. testcase list testrun result status displays the aggregrated test run result status of all executed testcases. testcase testrun result status displays the test run result status of an individual testcase. import testcases from JSON loads testcase information from a JSON file export selected testcases as JSON creates a JSON representation of the selected testcases and stores them to a file rename selected testcase","title":"Special considerations"},{"location":"views-repositories-testsets/#teststep-list-view","text":"This view displays the teststeps of the selected testcase A teststep performs - depending on the teststep type a type-specific task within a testcase.","title":"Teststep list view"},{"location":"views-repositories-testsets/#commands_1","text":"Create SOAP Teststep opens a dialog to specify the WSDL and the operation that you want to test. See tutorial Create SOAP Teststep Create HTTP Teststep creates a teststep for HTTP requests including JSON body. See tutorial Create HTTP Teststep Create Datatransfer Teststep creates a teststep with an empty list of Teststep value providers such as XPath and XQuery value providers. See Datatransfer Teststep Create RandomizeTeststep creates a teststep with an empty list of random value providers based on concatenated strings or uuids. See View Randomizeteststep Create Randomized ValuelistTeststep creates a teststep that reads a CSV file and allows to configure output columns and their formatting. See Randomizedvaluelist Teststep View . Create Manual Randomized ValuelistTeststep creates a teststep that let you edit a table and allows to configure output columns and their formatting. see Manual RandomizedvaluelistTeststep View . Each Teststep type is displayed with its name and a specific icon to distinguish the teststep type. delete all selected teststeps rename selected teststep move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to define which teststep needs the input of another teststep. enable/disable includes or excludes a teststep on a test run run test starts a test run that walks through all selected teststep in the displayed order, or all teststeps, when no teststep is selected. teststep list testrun result status displays the aggregrated test run result status of all executed teststeps. teststep testrun result status displays the test run result status of an individual teststep. Documentation of the Pasteboard commands","title":"Commands"},{"location":"views-teststeps/","text":"HTTP Teststep View A HTTP Teststep allows you to send a HTTP request for several HTTP methods such as GET, POST and PUT. Additionally, you may send JSON in the HTTP-Body. See Create HTTP Teststep , to add a new HTTP Teststep for a testcase The screenshot contain sample URLs from the ITunes store, provided on iTunes Search API Documentation Archive Please don't understand these screenshots as any kind of endorsement from Apple\u00ae for this software. Request overview The Request editor provides four tabs, we will cover these in the order they appear on the screen. Request (Tab) URL: Enter the URL that you want to test against. URL edit mode: There are three url edit modes available. We will cover these below Selected HTTP Teststep The HTTP Teststep editor appears, when you select an HTTP Teststep in the teststep list Run URL request Press this button to send yor URL request to the URL Response viewer: This viewer displays the JSON content and may be empty, if no content is returned from the server. URL edit mode There are three url edit modes: URL as a single String: You enter the full url including host, port, route and query parameters, this is the default URL with separate list of query parameters: You have separate input fields for schema, host, port, route and an editable list of query parameters URL with separate list for route parameters and query parameters: You have separate input fields for schema, host, port and editable lists of route parameters and query parameters Configure your request The HTTP teststep configuration allows you the select the HTTP method and the authentication method (none, basic authentication and bearer authentication). Supported HTTP methods - GET - POST - PUT - DELETE - HEAD - PATCH Supported MIME content types for POST and PUT - application/json - text/xml - application/soap+xml resolvedRequest (Tab) This viewer show the request with resolved variable values Header fields This view displays the HTTP headers used for the URL request. You may create your custom set of HTTP headers for test reasons. use manual header fields: Set the toggle to true, to override the automatic header field configuration. Add new HTTP Header: Creates a new header. There is no automatic check for duplicate names, use the Button check for duplicates to perform this check. check for duplicates: Header fields names must be unique, If you use manual header fields, press this button to check for duplicates arbitrary selection to remove elements: You can select arbitrary elements to remove these. remove selected elements: Press this button to remove the selected elements. This has only an effect, if you use manual headers. assertions The assertion list view is described here: HTTP Teststep assertion list SOAP Teststep View A SOAP Teststep is a WSDL-aware Teststep that reference a specific webservice method. You have request and response area with various that help you manage the complexity of SOAP-XML data models based on WSDL-XSD-Schema definition. Run your SOAP request and verify the response. You can view the HTTP header fields for request and response. A Soap Teststep is created based on a WSDL operation either for a SOAP 1.1 or SOAP 1.2 WsdlService Port Overview The SOAP Teststep View provides a number of sub views and configuration options. Teststep configuration options that effects request and response handling. A Request view with a number of views that shows request information A Response view with a number of views that show response information Teststep configuration options Teststep configuration view Send Request with MTOM will transform your request in the required MTOM request format and replace all occurrences of elements of type {http://www.w3.org/2005/05/xmlmime} base64Binary with the {http://www.w3.org/2004/08/xop/include }Include. It will apply all required transformations to create a valid MTOM optimized request. Resolve XOP:include in Response transforms an MTOM-optimized response to a response without optimizations. It will inline the SOAPAttachment data and transform all occurrences of {http://www.w3.org/2004/08/xop/include }Include with {http://www.w3.org/2005/05/xmlmime} base64Binary Webservice url is required to send the request to the webservice endpoint under test. If you choose to use View Environment and have configured the webservice urls for this WSDL and the selected Run Environment, the url becomes non-editable. If no authentication is selected the HTTP header autorization is omitted otherwise sent with the base64 encoded string of username for basic authentication and password for basic authentication as displayed in preview base64 encoded authentication string . WSDL operation reference is a required setting for a SOAP Teststep. APIJockey TEST uses the WSDL-definitions to validate the request and the response. It allows for using MTOM-optimized requests as described above. When you click on the binocular button, you will get a dialog with a list of WSDL definitions with their SOAP 1.1. and SOAP 1.2 operations. Authentication options include no authentication , basic authentication with username and password and bearer authentication with bearer token in a free to define http header. SOAP Request editor overview The request view contains several tabs to display different information Request with variables your XML editor with syntax highlighting XML editor is a visual tree-like editor that allows you to edit XML elements with text content and select variables. Request with variable values resolved . Viewer that resolves values of Variables Assertions based on simplified XPath that assert occurrences of specified elements. Details see below Attachments allow for selection and preview of documents that you want to send with your request. URLRequest Details displays the HTTP headers used to create the request. Tab Request with variables Run Teststep will send the request to the specified URL, wait for the response and run all assertions against the response. Request editor is your Syntax-Highlighting editor to work on your request Create new request from WSDL operation will delete your current request and create a new one based on the current WSDL operation information. Validate request will validate against the WSDL operation information and displays errors in case of non-conformance with this specification. Pretty print XML does indents and create newlines for each element. You enter your request in this syntax highlighting XML editor. Variables are colored to make them easy to distinguish, see Variables XML editor The XML editor provides an additional edit option, with focus on XML elements that have text content and where the structure does not need to be changed. This is often the case for existing requests where values only need to be variable-ized or just changed. NOTE: Press the ENTER key when editing is done to update the underlying xml. Request with variable values resolved When you use variables, see Variables their name/value will be represented as follows: tab Request with Variables as a highlighted variable identifier tab XML editor no highlighting of the variable identifier tab Request with Variables resolved with the current variable value, Attachment references are NOT resolved When you switch from your request editor to this tab, APIJockey TEST will reevaluate the variables and resolve these as it does when sending the request. Bear in mind that this is only a viewer. Assertions Testing webservices can become repetitive and cumbersome. Assertions help you to automate checks and free you from repetitive error-prone verifications. You will find more time to further explore responses and find unexpected behaviour. Assertions have their own tab in the SOAP Request view and allow you for editing assertions while viewing the Response. APIJockey TEST supports the following assertions types create a new XPath Assertion to verify the SOAP Response with an XPath expresssion. APIJockey TEST will support you with a visual editor to enter the XPath and to define the type of verification. See XPath Assertion editor . create a new HTTP Assertion HTTP Status, response time and data length, see HTTP Assertion editor create a new Image Assertion will create an AI-based Assertion that will assess Text and Barcode information from your image. Note: PDF-Documents are also considered images in this Assertion type.See Image Assertion editor create a new PDF Assertion will create a PDF Assertion that will assess Text and document property information from your PDF-Document. Note: Sometimes PDF-Documents contain images, only and no text will be found. See PDF Assertion editor . In this case, you will need to use the Image Assertion type. Attachments Attachments are used in both requests and responses. URL request header This tab displays the HTTP header used with the last URL request and may be empty if no request has been sent after (re-)starting APIJockey TEST. View DatatransferTeststep A Datatransfer teststep allows you to query results from SOAP teststeps (request and response) and store them in a variable. This is helpful in cases where you need to establish a set of requests where the input of a request is part of the response of the previous teststep.. Overview When you create and select Datatransfer Teststep in the Teststep list view , the following editor appears. create new XPath expression opens a dialog to create an xpath expression to query data from a previous teststep (request or response) in this testcase.. create new XQuery expression opens a dialog to create an xpath expression to query data from a previous teststep (request or response) in this testcase. Note that you will use XPath in XQuery as well, so depending on your use case, XQuery may be the choice.. delete the selected datatransfers rename the selected datatransfer run datatransfer needs a referenced variable. See VariableValueTransfer for details run result status displays the test run result status of an individual teststep. enable/disable includes or excludes a datatransfer on a test run move up and move down has impact on the list order and on the order they are invoked for test runs. As the datatransfers query teststep request and response they cannot have dependencies on each other. The order is intendedfor your organization, only. Documentation of the pasteboard commands Walkthrough to create an XPath datatransfer We will create an XPath datatransfer (value provider) with a namespace-aware XPath expression. Be aware that we will use the request for this XPath expression. In general, you may use the response for your query. To make this work, you need to walk through our getting started tutorial . Once you are done, you need to change the request as follows: We will query the value of msg:Element and store it in a testcase variable <div> <pre> &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt; &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt;&lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;msg:Enumerate xmlns:msg=\"http://schemas.xmlsoap.org/ws/2004/09/enumeration\"&gt; &lt;!-- continue here --&gt; &lt;msg:Element&gt;USD&lt;/msg:Element&gt; &lt;/msg:Enumerate&gt; &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt; </pre> </div> * > Input configuration Click with your mouse on the button create new XPath expression . This will open a dialog. Enter the name currency and confirm with ok . You will see the new datatransfer value provider in the list. Click with your mouse on the teststep Enumerate . This will link the teststep with the value provider and display the following view: You may remove the current teststep reference with the button remove configuration . read from You may switch to request/response of the referenced teststep to query data, default is response . We need to reference the request for our walkthrough. For this reason the screenshot displays the value request after change from the default as the input type of the value provider. We enter a simple, namespace aware XPath-Expression. //msg:Element/text() Now, we run this XPath expression and will get an error message Click with your mouse on the button run XPath value provider This will show an error message. The reason for the error message is an unsatisfied mapping from the prefix to the namespace. This can be resolved very easily. Click on the button remove error message as we don't need this error message. Switch to to the tab Namspaces and click with your mouse on the button preset namespaces from input teststep This will load the namespaced defined in the input XML (request) with the prefixes used in the XML. You may run the XPath expression again, and will get error message that no variable has been loaded. Create your own testcase variable currency . In case you're uncertain, how to proceed, see Create a VariableValueTransfer . Then run the value provider again. The result should be as follows: View Randomizeteststep This teststep editor lets you manage a list of random value providers based on String, Integer, Double, Date and UUID data types. Discussion A Randomizeteststep supports a list of random values that store their values in variables. When you select a Randomizeteststep. you will see an empty editor, as in the screenshot below. A random value provider creates a Text/String based on a list of individual value sub elements from different data types. It is a powerful randomizing utility, and you may need to get used it. The fact that no coding is necessary may make this one of your favorite tools to randomize you requests. Commands create new random value creates a new random value provider. rename selected element delete all selected elements move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to define which teststep needs the input of another teststep. run value provider list regenerates new random values for all selected elements in the displayed order, or all elements, when no element is selected. Documentation of the pasteboard commands RandomValueProviders A RandomizeTeststep includes an (initially empty) list of RandomValueProviders When you need to provide several independent random values at a certain point in your teststep order, you would need a list of RandomValueProvider. depending on your underlying data type, you have to choose between: Text : Creates an expression value with arbitrary characters in a specified length Integer : Creates an expression value between a lower range and an upper range in a specified formatting Double : Creates an expression value between a lower range and an upper range in a specified formatting Date : Creates an expression value between a lower range and an upper range in a specified formatting UUID : Creates a UUID rename : opens a dialog to rename a selected element delete : deletes the selection move up : moves the selection up in the list move down: moves the selection down in the list enable : enables/disables the selection run expressions : The RandomValueProvider returns a concatenation of the expressions from top to down as one result. Text Randomvalue expression n Use this type if you want to create a text with arbitrary characters that may occur in a fixed length value. (/storage/RandomizeTeststep-VariableTextExpression.png\" alt=\"screenshot RandomizeTeststep variable text expression\"/> current random value displays the result of the random value generation. text length defines, how long the text should be. Each character can be one of included characters . This behaviour is applied, when you choose the value expression type variable random text A text random value expression may be part of a list of expression. Part of this concatenated text may be a fix character string, e.g. the first three characters must be ABC Integer RandomValueExpression Use this, if you want to provide an integer random value between a lower and an upper range with or without formatting. Usage instructions define the included lower range define the excluded upper range set the formatting for positive numbers set the formatting for negative numbers . It might be the case that you want to return a negative number as its absolute value Double RandomValueExpression Use this, if you want to provide a random double value between a lower and an upper range with or without formatting. Usage instructions define the included lower range define the excluded upper range set the formatting for positive numbers . This may include special characters as a currency indicator. set the formatting for negative numbers . Date RandomValueExpression Use this, if you want to provide a random formatted date between a lower and an upper range with or without formatting. Usage instructions set the first possible date set the last possible date (excluded) set the mandatory formatting . UUID RandomValueExpression Use this, if you need a unique identifier, e.g. to have a trace in your logging system. VariableValueTransfer Once you have set up the RandomValueProvider, you will need to define the VariableValueTransfer Manual RandomizedvaluelistTeststep View A Manual Randomizedvaluelist teststep takes a list of columns with equal number of row and provides randomized values from this table in variables that can be used in following teststeps. The purpose is to permute data to a maximum. This helps to test efficiently webservices with a varying (even small) set of test data. A small number of data can thus provide more combinations when repeating a test. Repeating testcases without data variations has only limited benefits. You would not test thoroughly, and test all combinations of testcases is an endeavour that only few testers will continue to perform in the sense of regression testing. See Create a RandomizedValuelist Teststep to add this teststep. Overview of the configuration options Manual Randomized Valuelist Teststep overview The view contains three main parts Column editor (blue bordered area) Variables transfer (red bordered area) Editable table The teststep configuration foresees the following elements: Manual Randomizedvaluelist Teststep view details Column editor view You maintain a list of columns for your editable tables. The current columns are displayed as a list with configuration information add column creates a new column. This will create empty contents for existing rows and a testcase variable that is referencing this column. Enable column(s) : A column value is transferred to a variable only, if the column is enabled. You may exclude (ignore) columns in a CSV file. That way you don't need to modify the CSV file itself. All selected columns are enabled independent of their current state. Disable column(s) : The selected columns are disabled. No value will be transferred to the connected variable. IF there is a value in the variable e.g. due to manual editing or previous runs, this value will remain. You may optionally remove the variable. A column that is disabled has the platform specific secondary color, in general this is grey instead of dark black text color, both in the column list and the Value list preview on the right side. display column(s) : A column can be displayed and not displayed in the preview. This may help you to focus on specific columns during editing. This has impact on the actual transferral on variables. A column that is shown has a different Icon that one that is not displayed. Hide column(s) : Removes all selected columns from the preview, You may focus on a single column or any subset of columns that you want to inspect and/or format. rename column will rename the current column in the table. delete column removes all selected columns from existing rows. (Show) Output view (Variables' transfer configuration) This is explained in full detail in Output view (Variables' transfer configuration) in Randomizedvaluelist Teststep . Editable table This editable table displays all shown columns . No further formatting applies. The following screenshot shows: two defined columns (first name, last name add single row will add a single row for all columns add number of rows will show a dialog where you enter the number of rows and create the number of rows delete selected row(s) will delete the selected rows without further warning! table rows show only columns with diplay equals true (see Column editor view) Randomizedvaluelist Teststep View A Randomizedvaluelist Teststep takes a table of values (CSV-File technically) and provides randomized values from this table in variables that can be used in web service requests. The purpose is to permutate request data to a maximum. This helps to test efficiently webservices with a varying (even small) set of test data. A small number of data can thus provide more combinations when repeating a test. Repeating testcase without variation has only limited benefits. You would not test thoroughly and test all combinations of testcases is an endeavour that only few testers will continue to perform in the sense of regression testing. See Create a RandomizedValuelist Teststep to add a new RandomizedValuelist Teststep for a testcase. Overview of the configuration options The teststep configuration foresees the following elements: enable/disable columns randomizing on a row base or randomizing for each column show/hide columns configure the output variables (name / parent element) The following example displays favorite U.S. first and common last names, together with a combination of some postal codes and states. The premise is to combine first and last names randomly and keep a given postal code and state combination. We would use two Randomizedvaluelist teststeps to perform this task. Randomizedvaluelist Teststep view details The view contains three main parts Column editor (upper left) and column formatting Variables transfer (lower left) Formatted value list preview (table view on the right) Column editor view A CSV file is interpreted as a list of rows consisting of equal columns. You may have been provided with a file and may configure the columns that you want to use and foresee further formatting Enable columns : A column value is transferred to a variable only, if the column is enabled. You may exclude (ignore) columns in a CSV file. That way you don't need to modify the CSV file itself. All selected columns are enabled independent of their current state. Disable columns : The selected columns are disabled. No value will be transferred to the connected variable. IF there is a value in the variable e.g. due to manual editing or previous runs, this value will remain. You may optionally remove the variable. A column that is disabled has the platform specific secondary color, in general this is grey instead of dark black text color, both in the column list and the Value list preview on the right side. Show columns : A column can be displayed and not displayed in the preview. This may help you to focus on specific columns during editing. This has impact on the actual transferral on variables. A column that is shown has a different Icon that one that is not displayed. Hide columns : Removes all selected columns from the preview, You may focus on a single column or any subset of columns that you want to inspect and/or format. Formatting The formatting view is visible when you select a single column in the column editor view. The formatting options depend on the underlying type that was identified during the process of reading the CSV file. String values Numbers (Integers, Double, Float) Dates String values can be any text, boolean values or dates in text representations that are not recognized. While booleans can be easily interpreted by changing the reading options> the text representation of dates may vary for each column. Therefore, you may choose to redefine a column value type from string to date and apply formatting for the data when transferred to a variable: Numbers (Integers, Double, Float) are in general easy to interpret, Here you can apply a number formatting for positive and negative values: Dates are identified if they follow the ISO 8601 string representation . If the CSV file holds dates with a different date format, you may still process them by applying the Treat as Date flag. Output view (Variables' transfer configuration) A randomized value list foresees a variable transfer for each column that is enabled. The variables can be connected to the testcase, parent teststep or parent repository. You will only be able to run the teststep successfully, when you have created and connected variables to each individual columns. This can be done with a single click and repeated whenever required. Show output view (variables connected with columns) : shows or hides the entire view. Once the configuration is done you may hide this view. run randomize teststep and update variables : This command is equal to the run command in the teststep list view. It provides a randomized value for each column and updates the referenced variable. select randomize type You may want to randomize columns independently or row-based. In our example file, you may want to randomize first names and last names independently. You may want to keep the columns postal code and state together. In This case you would work with two teststeps referring the same CSV file. run randomize teststep and preview results : This command can be run without referenced variables. It displays the randomized values for all enabled columns with their respective formatting . default connect between variables and columns : Each column must be assigned a variable in order for the randomized value to be transferred. This command would create a variable for each enabled column. When you click this button again, the existing variables will be deleted and replaced by a new set of variables. You may change the variables reference in the. Manual configuration of the variables' transfer When you select a single line in the output view, the view is split in two vertical sections. The output view shrinks horizontally and provides the option to edit the variables transfer reference. The selected column value displays name and value of the randomized column. The button remove variable reference gives the option to configure a different variable reference by selecting the parent testcase, testset or repository and select one of their attached variables including creating a new variable. variable value displays the current value of the referenced variable. This should be same value as the randomized Formatted value list preview The formatted value list preview displays all rows in the CSV file with all shown columns and applied formatting for each column. Button Show/hide CSV reading config button (un)discloses a button to show the CSV reading configuration. open configuration button opens a dialog to configure the options when a CSV is read. file url : When you select a file from your desktop, the file url is stored. The file data is read and its contents are stored with the formatting options as separate information. Button source data reads the file url data and displays the data in text file view without overriding any column configurations. number of rows in file displays the number of rows applying the configuration option empty lines . CSV file data with configuration displays the formatted columns. Columns that are disabled are shown with the system' secondary color, this may be gray instead of black text color on your system. CSV file reading options A CSV file may have various textual representations. Depending on your output requirement you may need to modify the default values. You MUST provide row headers you may ignore empty lines, they will not appear as rows in the preview data list Your CSV file may use escaping, verify if the escape character fits Your CSV file may use quotes for your columns You may list a set of false encodings You may list a set of nil encodings You may list a set of true encodings OK saves your changes and dismisses the dialog Cancel flushes your changes and dismisses the dialog HTTP Teststep assertion list Testing webservices can become repetitive and cumbersome. Assertions help you to automate checks and free you from repetitive error-prone verifications. You will find more time to further explore responses and find unexpected behaviour. Assertions have their own tab in the HTTP Request view and allow you for editing assertions while viewing the Response. Assertions Assertions help you to assess the validity of a teststeps output. APIJockey TEST provides a set of assertions types depending on the output type unter test. Assertion list We discuss the list buttons in the order they appear in the view from left to right Create new HTTP assertion: See HTTP assertion editor Create new JSON assertion with JSONPath. See JSONPath assertion editor Create new Image Assertion. See AI based Image Assertions Create new PDF Assertion. See PDF Assertions Delete selected Assertion(s) Rename selected Assertion Move up selection in the list Move down selection in the list Enable/disable: An assertion will only be executed, if it is enabled. A disabled assertion appears with grey text color. Run (selected assertion or all assertion): This button runs all selected elements in the order they appear. If no assertion is selected, the whole list will be run. List of assertions with current result status Displays the name of the assertion and the result status Pasteboard commands Assertion editor: Empty view in the screenshot, as no Assertion is selected in the list. See details for each type of assertion in the","title":"Testep views"},{"location":"views-teststeps/#http-teststep-view","text":"A HTTP Teststep allows you to send a HTTP request for several HTTP methods such as GET, POST and PUT. Additionally, you may send JSON in the HTTP-Body. See Create HTTP Teststep , to add a new HTTP Teststep for a testcase The screenshot contain sample URLs from the ITunes store, provided on iTunes Search API Documentation Archive Please don't understand these screenshots as any kind of endorsement from Apple\u00ae for this software.","title":"HTTP Teststep View"},{"location":"views-teststeps/#request-overview","text":"The Request editor provides four tabs, we will cover these in the order they appear on the screen.","title":"Request overview"},{"location":"views-teststeps/#request-tab","text":"URL: Enter the URL that you want to test against. URL edit mode: There are three url edit modes available. We will cover these below Selected HTTP Teststep The HTTP Teststep editor appears, when you select an HTTP Teststep in the teststep list Run URL request Press this button to send yor URL request to the URL Response viewer: This viewer displays the JSON content and may be empty, if no content is returned from the server.","title":"Request (Tab)"},{"location":"views-teststeps/#url-edit-mode","text":"There are three url edit modes: URL as a single String: You enter the full url including host, port, route and query parameters, this is the default URL with separate list of query parameters: You have separate input fields for schema, host, port, route and an editable list of query parameters URL with separate list for route parameters and query parameters: You have separate input fields for schema, host, port and editable lists of route parameters and query parameters","title":"URL edit mode"},{"location":"views-teststeps/#configure-your-request","text":"The HTTP teststep configuration allows you the select the HTTP method and the authentication method (none, basic authentication and bearer authentication).","title":"Configure your request"},{"location":"views-teststeps/#supported-http-methods","text":"- GET - POST - PUT - DELETE - HEAD - PATCH","title":"Supported HTTP methods"},{"location":"views-teststeps/#supported-mime-content-types-for-post-and-put","text":"- application/json - text/xml - application/soap+xml","title":"Supported MIME content types for POST and PUT"},{"location":"views-teststeps/#resolvedrequest-tab","text":"This viewer show the request with resolved variable values","title":"resolvedRequest (Tab)"},{"location":"views-teststeps/#header-fields","text":"This view displays the HTTP headers used for the URL request. You may create your custom set of HTTP headers for test reasons. use manual header fields: Set the toggle to true, to override the automatic header field configuration. Add new HTTP Header: Creates a new header. There is no automatic check for duplicate names, use the Button check for duplicates to perform this check. check for duplicates: Header fields names must be unique, If you use manual header fields, press this button to check for duplicates arbitrary selection to remove elements: You can select arbitrary elements to remove these. remove selected elements: Press this button to remove the selected elements. This has only an effect, if you use manual headers.","title":"Header fields"},{"location":"views-teststeps/#assertions","text":"The assertion list view is described here: HTTP Teststep assertion list","title":"assertions"},{"location":"views-teststeps/#soap-teststep-view","text":"A SOAP Teststep is a WSDL-aware Teststep that reference a specific webservice method. You have request and response area with various that help you manage the complexity of SOAP-XML data models based on WSDL-XSD-Schema definition. Run your SOAP request and verify the response. You can view the HTTP header fields for request and response. A Soap Teststep is created based on a WSDL operation either for a SOAP 1.1 or SOAP 1.2 WsdlService Port","title":"SOAP Teststep View"},{"location":"views-teststeps/#overview","text":"The SOAP Teststep View provides a number of sub views and configuration options. Teststep configuration options that effects request and response handling. A Request view with a number of views that shows request information A Response view with a number of views that show response information","title":"Overview"},{"location":"views-teststeps/#teststep-configuration-options","text":"","title":"Teststep configuration options"},{"location":"views-teststeps/#teststep-configuration-view","text":"Send Request with MTOM will transform your request in the required MTOM request format and replace all occurrences of elements of type {http://www.w3.org/2005/05/xmlmime} base64Binary with the {http://www.w3.org/2004/08/xop/include }Include. It will apply all required transformations to create a valid MTOM optimized request. Resolve XOP:include in Response transforms an MTOM-optimized response to a response without optimizations. It will inline the SOAPAttachment data and transform all occurrences of {http://www.w3.org/2004/08/xop/include }Include with {http://www.w3.org/2005/05/xmlmime} base64Binary Webservice url is required to send the request to the webservice endpoint under test. If you choose to use View Environment and have configured the webservice urls for this WSDL and the selected Run Environment, the url becomes non-editable. If no authentication is selected the HTTP header autorization is omitted otherwise sent with the base64 encoded string of username for basic authentication and password for basic authentication as displayed in preview base64 encoded authentication string . WSDL operation reference is a required setting for a SOAP Teststep. APIJockey TEST uses the WSDL-definitions to validate the request and the response. It allows for using MTOM-optimized requests as described above. When you click on the binocular button, you will get a dialog with a list of WSDL definitions with their SOAP 1.1. and SOAP 1.2 operations. Authentication options include no authentication , basic authentication with username and password and bearer authentication with bearer token in a free to define http header.","title":"Teststep configuration view"},{"location":"views-teststeps/#soap-request-editor-overview","text":"The request view contains several tabs to display different information Request with variables your XML editor with syntax highlighting XML editor is a visual tree-like editor that allows you to edit XML elements with text content and select variables. Request with variable values resolved . Viewer that resolves values of Variables Assertions based on simplified XPath that assert occurrences of specified elements. Details see below Attachments allow for selection and preview of documents that you want to send with your request. URLRequest Details displays the HTTP headers used to create the request.","title":"SOAP Request editor overview"},{"location":"views-teststeps/#tab-request-with-variables","text":"Run Teststep will send the request to the specified URL, wait for the response and run all assertions against the response. Request editor is your Syntax-Highlighting editor to work on your request Create new request from WSDL operation will delete your current request and create a new one based on the current WSDL operation information. Validate request will validate against the WSDL operation information and displays errors in case of non-conformance with this specification. Pretty print XML does indents and create newlines for each element. You enter your request in this syntax highlighting XML editor. Variables are colored to make them easy to distinguish, see Variables","title":"Tab Request with variables"},{"location":"views-teststeps/#xml-editor","text":"The XML editor provides an additional edit option, with focus on XML elements that have text content and where the structure does not need to be changed. This is often the case for existing requests where values only need to be variable-ized or just changed. NOTE: Press the ENTER key when editing is done to update the underlying xml.","title":"XML editor"},{"location":"views-teststeps/#request-with-variable-values-resolved","text":"When you use variables, see Variables their name/value will be represented as follows: tab Request with Variables as a highlighted variable identifier tab XML editor no highlighting of the variable identifier tab Request with Variables resolved with the current variable value, Attachment references are NOT resolved When you switch from your request editor to this tab, APIJockey TEST will reevaluate the variables and resolve these as it does when sending the request. Bear in mind that this is only a viewer.","title":"Request with variable values resolved"},{"location":"views-teststeps/#assertions_1","text":"Testing webservices can become repetitive and cumbersome. Assertions help you to automate checks and free you from repetitive error-prone verifications. You will find more time to further explore responses and find unexpected behaviour. Assertions have their own tab in the SOAP Request view and allow you for editing assertions while viewing the Response. APIJockey TEST supports the following assertions types create a new XPath Assertion to verify the SOAP Response with an XPath expresssion. APIJockey TEST will support you with a visual editor to enter the XPath and to define the type of verification. See XPath Assertion editor . create a new HTTP Assertion HTTP Status, response time and data length, see HTTP Assertion editor create a new Image Assertion will create an AI-based Assertion that will assess Text and Barcode information from your image. Note: PDF-Documents are also considered images in this Assertion type.See Image Assertion editor create a new PDF Assertion will create a PDF Assertion that will assess Text and document property information from your PDF-Document. Note: Sometimes PDF-Documents contain images, only and no text will be found. See PDF Assertion editor . In this case, you will need to use the Image Assertion type.","title":"Assertions"},{"location":"views-teststeps/#attachments","text":"Attachments are used in both requests and responses.","title":"Attachments"},{"location":"views-teststeps/#url-request-header","text":"This tab displays the HTTP header used with the last URL request and may be empty if no request has been sent after (re-)starting APIJockey TEST.","title":"URL request header"},{"location":"views-teststeps/#view-datatransferteststep","text":"A Datatransfer teststep allows you to query results from SOAP teststeps (request and response) and store them in a variable. This is helpful in cases where you need to establish a set of requests where the input of a request is part of the response of the previous teststep..","title":"View DatatransferTeststep"},{"location":"views-teststeps/#overview_1","text":"When you create and select Datatransfer Teststep in the Teststep list view , the following editor appears. create new XPath expression opens a dialog to create an xpath expression to query data from a previous teststep (request or response) in this testcase.. create new XQuery expression opens a dialog to create an xpath expression to query data from a previous teststep (request or response) in this testcase. Note that you will use XPath in XQuery as well, so depending on your use case, XQuery may be the choice.. delete the selected datatransfers rename the selected datatransfer run datatransfer needs a referenced variable. See VariableValueTransfer for details run result status displays the test run result status of an individual teststep. enable/disable includes or excludes a datatransfer on a test run move up and move down has impact on the list order and on the order they are invoked for test runs. As the datatransfers query teststep request and response they cannot have dependencies on each other. The order is intendedfor your organization, only. Documentation of the pasteboard commands","title":"Overview"},{"location":"views-teststeps/#walkthrough-to-create-an-xpath-datatransfer","text":"We will create an XPath datatransfer (value provider) with a namespace-aware XPath expression. Be aware that we will use the request for this XPath expression. In general, you may use the response for your query. To make this work, you need to walk through our getting started tutorial . Once you are done, you need to change the request as follows: We will query the value of msg:Element and store it in a testcase variable <div> <pre> &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt; &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt;&lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;msg:Enumerate xmlns:msg=\"http://schemas.xmlsoap.org/ws/2004/09/enumeration\"&gt; &lt;!-- continue here --&gt; &lt;msg:Element&gt;USD&lt;/msg:Element&gt; &lt;/msg:Enumerate&gt; &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt; </pre> </div> * >","title":"Walkthrough to create an XPath datatransfer"},{"location":"views-teststeps/#input-configuration","text":"Click with your mouse on the button create new XPath expression . This will open a dialog. Enter the name currency and confirm with ok . You will see the new datatransfer value provider in the list. Click with your mouse on the teststep Enumerate . This will link the teststep with the value provider and display the following view: You may remove the current teststep reference with the button remove configuration . read from You may switch to request/response of the referenced teststep to query data, default is response . We need to reference the request for our walkthrough. For this reason the screenshot displays the value request after change from the default as the input type of the value provider. We enter a simple, namespace aware XPath-Expression. //msg:Element/text() Now, we run this XPath expression and will get an error message Click with your mouse on the button run XPath value provider This will show an error message. The reason for the error message is an unsatisfied mapping from the prefix to the namespace. This can be resolved very easily. Click on the button remove error message as we don't need this error message. Switch to to the tab Namspaces and click with your mouse on the button preset namespaces from input teststep This will load the namespaced defined in the input XML (request) with the prefixes used in the XML. You may run the XPath expression again, and will get error message that no variable has been loaded. Create your own testcase variable currency . In case you're uncertain, how to proceed, see Create a VariableValueTransfer . Then run the value provider again. The result should be as follows:","title":"Input configuration"},{"location":"views-teststeps/#view-randomizeteststep","text":"This teststep editor lets you manage a list of random value providers based on String, Integer, Double, Date and UUID data types.","title":"View Randomizeteststep"},{"location":"views-teststeps/#discussion","text":"A Randomizeteststep supports a list of random values that store their values in variables. When you select a Randomizeteststep. you will see an empty editor, as in the screenshot below. A random value provider creates a Text/String based on a list of individual value sub elements from different data types. It is a powerful randomizing utility, and you may need to get used it. The fact that no coding is necessary may make this one of your favorite tools to randomize you requests.","title":"Discussion"},{"location":"views-teststeps/#commands","text":"create new random value creates a new random value provider. rename selected element delete all selected elements move up and move down has impact on the list order and on the order they are invoked for test runs. The order is intended to define which teststep needs the input of another teststep. run value provider list regenerates new random values for all selected elements in the displayed order, or all elements, when no element is selected. Documentation of the pasteboard commands","title":"Commands"},{"location":"views-teststeps/#randomvalueproviders","text":"A RandomizeTeststep includes an (initially empty) list of RandomValueProviders When you need to provide several independent random values at a certain point in your teststep order, you would need a list of RandomValueProvider. depending on your underlying data type, you have to choose between: Text : Creates an expression value with arbitrary characters in a specified length Integer : Creates an expression value between a lower range and an upper range in a specified formatting Double : Creates an expression value between a lower range and an upper range in a specified formatting Date : Creates an expression value between a lower range and an upper range in a specified formatting UUID : Creates a UUID rename : opens a dialog to rename a selected element delete : deletes the selection move up : moves the selection up in the list move down: moves the selection down in the list enable : enables/disables the selection run expressions : The RandomValueProvider returns a concatenation of the expressions from top to down as one result.","title":"RandomValueProviders"},{"location":"views-teststeps/#text-randomvalue-expression","text":"n Use this type if you want to create a text with arbitrary characters that may occur in a fixed length value. (/storage/RandomizeTeststep-VariableTextExpression.png\" alt=\"screenshot RandomizeTeststep variable text expression\"/> current random value displays the result of the random value generation. text length defines, how long the text should be. Each character can be one of included characters . This behaviour is applied, when you choose the value expression type variable random text A text random value expression may be part of a list of expression. Part of this concatenated text may be a fix character string, e.g. the first three characters must be ABC","title":"Text Randomvalue expression"},{"location":"views-teststeps/#integer-randomvalueexpression","text":"Use this, if you want to provide an integer random value between a lower and an upper range with or without formatting. Usage instructions define the included lower range define the excluded upper range set the formatting for positive numbers set the formatting for negative numbers . It might be the case that you want to return a negative number as its absolute value","title":"Integer RandomValueExpression"},{"location":"views-teststeps/#double-randomvalueexpression","text":"Use this, if you want to provide a random double value between a lower and an upper range with or without formatting. Usage instructions define the included lower range define the excluded upper range set the formatting for positive numbers . This may include special characters as a currency indicator. set the formatting for negative numbers .","title":"Double RandomValueExpression"},{"location":"views-teststeps/#date-randomvalueexpression","text":"Use this, if you want to provide a random formatted date between a lower and an upper range with or without formatting. Usage instructions set the first possible date set the last possible date (excluded) set the mandatory formatting .","title":"Date RandomValueExpression"},{"location":"views-teststeps/#uuid-randomvalueexpression","text":"Use this, if you need a unique identifier, e.g. to have a trace in your logging system.","title":"UUID RandomValueExpression"},{"location":"views-teststeps/#variablevaluetransfer","text":"Once you have set up the RandomValueProvider, you will need to define the VariableValueTransfer","title":"VariableValueTransfer"},{"location":"views-teststeps/#manual-randomizedvaluelistteststep-view","text":"A Manual Randomizedvaluelist teststep takes a list of columns with equal number of row and provides randomized values from this table in variables that can be used in following teststeps. The purpose is to permute data to a maximum. This helps to test efficiently webservices with a varying (even small) set of test data. A small number of data can thus provide more combinations when repeating a test. Repeating testcases without data variations has only limited benefits. You would not test thoroughly, and test all combinations of testcases is an endeavour that only few testers will continue to perform in the sense of regression testing. See Create a RandomizedValuelist Teststep to add this teststep.","title":"Manual RandomizedvaluelistTeststep View"},{"location":"views-teststeps/#overview-of-the-configuration-options","text":"Manual Randomized Valuelist Teststep overview The view contains three main parts Column editor (blue bordered area) Variables transfer (red bordered area) Editable table The teststep configuration foresees the following elements:","title":"Overview of the configuration options"},{"location":"views-teststeps/#manual-randomizedvaluelist-teststep-view-details","text":"","title":"Manual Randomizedvaluelist Teststep view details"},{"location":"views-teststeps/#column-editor-view","text":"You maintain a list of columns for your editable tables. The current columns are displayed as a list with configuration information add column creates a new column. This will create empty contents for existing rows and a testcase variable that is referencing this column. Enable column(s) : A column value is transferred to a variable only, if the column is enabled. You may exclude (ignore) columns in a CSV file. That way you don't need to modify the CSV file itself. All selected columns are enabled independent of their current state. Disable column(s) : The selected columns are disabled. No value will be transferred to the connected variable. IF there is a value in the variable e.g. due to manual editing or previous runs, this value will remain. You may optionally remove the variable. A column that is disabled has the platform specific secondary color, in general this is grey instead of dark black text color, both in the column list and the Value list preview on the right side. display column(s) : A column can be displayed and not displayed in the preview. This may help you to focus on specific columns during editing. This has impact on the actual transferral on variables. A column that is shown has a different Icon that one that is not displayed. Hide column(s) : Removes all selected columns from the preview, You may focus on a single column or any subset of columns that you want to inspect and/or format. rename column will rename the current column in the table. delete column removes all selected columns from existing rows.","title":"Column editor view"},{"location":"views-teststeps/#show-output-view-variables-transfer-configuration","text":"This is explained in full detail in Output view (Variables' transfer configuration) in Randomizedvaluelist Teststep .","title":"(Show) Output view (Variables' transfer configuration)"},{"location":"views-teststeps/#editable-table","text":"This editable table displays all shown columns . No further formatting applies. The following screenshot shows: two defined columns (first name, last name add single row will add a single row for all columns add number of rows will show a dialog where you enter the number of rows and create the number of rows delete selected row(s) will delete the selected rows without further warning! table rows show only columns with diplay equals true (see Column editor view)","title":"Editable table"},{"location":"views-teststeps/#randomizedvaluelist-teststep-view","text":"A Randomizedvaluelist Teststep takes a table of values (CSV-File technically) and provides randomized values from this table in variables that can be used in web service requests. The purpose is to permutate request data to a maximum. This helps to test efficiently webservices with a varying (even small) set of test data. A small number of data can thus provide more combinations when repeating a test. Repeating testcase without variation has only limited benefits. You would not test thoroughly and test all combinations of testcases is an endeavour that only few testers will continue to perform in the sense of regression testing. See Create a RandomizedValuelist Teststep to add a new RandomizedValuelist Teststep for a testcase.","title":"Randomizedvaluelist Teststep View"},{"location":"views-teststeps/#overview-of-the-configuration-options_1","text":"The teststep configuration foresees the following elements: enable/disable columns randomizing on a row base or randomizing for each column show/hide columns configure the output variables (name / parent element) The following example displays favorite U.S. first and common last names, together with a combination of some postal codes and states. The premise is to combine first and last names randomly and keep a given postal code and state combination. We would use two Randomizedvaluelist teststeps to perform this task.","title":"Overview of the configuration options"},{"location":"views-teststeps/#randomizedvaluelist-teststep-view-details","text":"The view contains three main parts Column editor (upper left) and column formatting Variables transfer (lower left) Formatted value list preview (table view on the right)","title":"Randomizedvaluelist Teststep view details"},{"location":"views-teststeps/#column-editor-view_1","text":"A CSV file is interpreted as a list of rows consisting of equal columns. You may have been provided with a file and may configure the columns that you want to use and foresee further formatting Enable columns : A column value is transferred to a variable only, if the column is enabled. You may exclude (ignore) columns in a CSV file. That way you don't need to modify the CSV file itself. All selected columns are enabled independent of their current state. Disable columns : The selected columns are disabled. No value will be transferred to the connected variable. IF there is a value in the variable e.g. due to manual editing or previous runs, this value will remain. You may optionally remove the variable. A column that is disabled has the platform specific secondary color, in general this is grey instead of dark black text color, both in the column list and the Value list preview on the right side. Show columns : A column can be displayed and not displayed in the preview. This may help you to focus on specific columns during editing. This has impact on the actual transferral on variables. A column that is shown has a different Icon that one that is not displayed. Hide columns : Removes all selected columns from the preview, You may focus on a single column or any subset of columns that you want to inspect and/or format.","title":"Column editor view"},{"location":"views-teststeps/#formatting","text":"The formatting view is visible when you select a single column in the column editor view. The formatting options depend on the underlying type that was identified during the process of reading the CSV file. String values Numbers (Integers, Double, Float) Dates String values can be any text, boolean values or dates in text representations that are not recognized. While booleans can be easily interpreted by changing the reading options> the text representation of dates may vary for each column. Therefore, you may choose to redefine a column value type from string to date and apply formatting for the data when transferred to a variable: Numbers (Integers, Double, Float) are in general easy to interpret, Here you can apply a number formatting for positive and negative values: Dates are identified if they follow the ISO 8601 string representation . If the CSV file holds dates with a different date format, you may still process them by applying the Treat as Date flag.","title":"Formatting"},{"location":"views-teststeps/#output-view-variables-transfer-configuration","text":"A randomized value list foresees a variable transfer for each column that is enabled. The variables can be connected to the testcase, parent teststep or parent repository. You will only be able to run the teststep successfully, when you have created and connected variables to each individual columns. This can be done with a single click and repeated whenever required. Show output view (variables connected with columns) : shows or hides the entire view. Once the configuration is done you may hide this view. run randomize teststep and update variables : This command is equal to the run command in the teststep list view. It provides a randomized value for each column and updates the referenced variable. select randomize type You may want to randomize columns independently or row-based. In our example file, you may want to randomize first names and last names independently. You may want to keep the columns postal code and state together. In This case you would work with two teststeps referring the same CSV file. run randomize teststep and preview results : This command can be run without referenced variables. It displays the randomized values for all enabled columns with their respective formatting . default connect between variables and columns : Each column must be assigned a variable in order for the randomized value to be transferred. This command would create a variable for each enabled column. When you click this button again, the existing variables will be deleted and replaced by a new set of variables. You may change the variables reference in the.","title":"Output view (Variables' transfer configuration)"},{"location":"views-teststeps/#manual-configuration-of-the-variables-transfer","text":"When you select a single line in the output view, the view is split in two vertical sections. The output view shrinks horizontally and provides the option to edit the variables transfer reference. The selected column value displays name and value of the randomized column. The button remove variable reference gives the option to configure a different variable reference by selecting the parent testcase, testset or repository and select one of their attached variables including creating a new variable. variable value displays the current value of the referenced variable. This should be same value as the randomized","title":"Manual configuration of the variables' transfer"},{"location":"views-teststeps/#formatted-value-list-preview","text":"The formatted value list preview displays all rows in the CSV file with all shown columns and applied formatting for each column. Button Show/hide CSV reading config button (un)discloses a button to show the CSV reading configuration. open configuration button opens a dialog to configure the options when a CSV is read. file url : When you select a file from your desktop, the file url is stored. The file data is read and its contents are stored with the formatting options as separate information. Button source data reads the file url data and displays the data in text file view without overriding any column configurations. number of rows in file displays the number of rows applying the configuration option empty lines . CSV file data with configuration displays the formatted columns. Columns that are disabled are shown with the system' secondary color, this may be gray instead of black text color on your system.","title":"Formatted value list preview"},{"location":"views-teststeps/#csv-file-reading-options","text":"A CSV file may have various textual representations. Depending on your output requirement you may need to modify the default values. You MUST provide row headers you may ignore empty lines, they will not appear as rows in the preview data list Your CSV file may use escaping, verify if the escape character fits Your CSV file may use quotes for your columns You may list a set of false encodings You may list a set of nil encodings You may list a set of true encodings OK saves your changes and dismisses the dialog Cancel flushes your changes and dismisses the dialog","title":"CSV file reading options"},{"location":"views-teststeps/#http-teststep-assertion-list","text":"Testing webservices can become repetitive and cumbersome. Assertions help you to automate checks and free you from repetitive error-prone verifications. You will find more time to further explore responses and find unexpected behaviour. Assertions have their own tab in the HTTP Request view and allow you for editing assertions while viewing the Response.","title":"HTTP Teststep assertion list"},{"location":"views-teststeps/#assertions_2","text":"Assertions help you to assess the validity of a teststeps output. APIJockey TEST provides a set of assertions types depending on the output type unter test.","title":"Assertions"},{"location":"views-teststeps/#assertion-list","text":"We discuss the list buttons in the order they appear in the view from left to right Create new HTTP assertion: See HTTP assertion editor Create new JSON assertion with JSONPath. See JSONPath assertion editor Create new Image Assertion. See AI based Image Assertions Create new PDF Assertion. See PDF Assertions Delete selected Assertion(s) Rename selected Assertion Move up selection in the list Move down selection in the list Enable/disable: An assertion will only be executed, if it is enabled. A disabled assertion appears with grey text color. Run (selected assertion or all assertion): This button runs all selected elements in the order they appear. If no assertion is selected, the whole list will be run. List of assertions with current result status Displays the name of the assertion and the result status Pasteboard commands Assertion editor: Empty view in the screenshot, as no Assertion is selected in the list. See details for each type of assertion in the","title":"Assertion list"}]}